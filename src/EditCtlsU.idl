//////////////////////////////////////////////////////////////////////
/// \mainpage EditControls Documentation
///
/// \section intro_sec Introduction
///
/// %EditControls is a collection of edit control-like ActiveX controls. The \c HotKeyBox control wraps
/// the \c msctls_hotkey32 window class, the \c IPAddressBox control wraps the \c SysIPAddress32 window
/// class, the \c TextBox control wraps the \c Edit window class and the \c UpDownTextBox control combines
/// the \c Edit and \c msctls_updown32 window classes.\n
/// The controls are optimized for Visual Basic 6.0, but should also work in any other environment that
/// supports COM controls.
///
/// \section basics_sec Basics
///
/// The controls superclass the mentioned native window classes of Windows: \c msctls_hotkey32,
/// \c SysIPAddress32, \c Edit and \c msctls_updown32. Although I tried to wrap all features of these
/// window classes (status: Windows 10), some things may be missing. In these cases you usually may use
/// the Win32 API and handle the controls as native windows of the corresponding class. One of my goals was
/// it to create controls that may be controlled via API as well as via the classes that I implemented.
///
/// \section reqs_sec Requirements
///
/// %EditControls Unicode runs on the following operating systems:
/// - Windows XP (SP3 or later)
/// - Windows Server 2003 (SP2 or later)
/// - Windows Vista (SP2 or later)
/// - Windows Server 2008 (SP2 or later)
/// - Windows 7 (SP1 or later)
/// - Windows Server 2008 R2 (SP1 or later)
/// - Windows 8
/// - Windows Server 2012
/// - Windows 8.1
/// - Windows Server 2012 R2
/// - Windows 10
/// - Windows Server 2016
/// - Systems supported by Wine (Wine is a Win32 subsystem for alternative operating systems) - <strong>limited support</strong>
/// - ReactOS (a free Windows XP clone) - <strong>limited support</strong>
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system tagged with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// Although there's no entitlement to support, you've good chances to get help if you either post
/// to the <a href="https://www.timosoft-software.de/forum/viewforum.php?f=31">forums</a> or
/// <a href="mailto:Timo@TimoSoft-Software.de">send me a mail</a>.\n
/// Bugs and feature requests should be entered into the <a href="https://bugtracker.timosoft-software.de">bug tracking system</a>.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2006-2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - <a href="https://www.geoffchappell.com">Geoff Chappell</a>, for his website about undocumented Win32
///   API stuff.
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian LÃ¼tgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is the \c Font property ignored?</strong>\n
/// It isn't. My controls have a property \c UseSystemFont which defaults to \c True. This property tells
/// the control to use the system font rather than the font set by the \c Font property.\n
/// Why is this property's default \c True? Well, if I set system wide settings (like fonts) I expect all
/// applications to follow them. Unfortunately ignoring system wide settings seems to be trendy, so see
/// my decision as an educational measure.
///
/// <strong>2. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
///
/// <strong>3. What is the maximum length of the text that the \c TextBox control can handle?</strong>\n
/// The magical value is 65535. This is the maximum number of characters that the \c TextBox control can
/// handle without problems. The control can display longer texts, but some features (e. g. drag'n'drop)
/// won't work correctly then. This is due to limitations of the native \c Edit control.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace EditCtlsLibU
/// \brief <em>Contains COM definitions for the controls' public interfaces</em>
///
/// This is the Unicode version of the EditControls COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(A8F9B8E7-E699-4fce-A647-72C877F8E632),
	version(1.10),
	helpstring("TimoSoft EditControls 1.10 (Unicode)")
]
library EditCtlsLibU
{
	importlib("stdole2.tlb");


	/// \brief <em>Constants used with the \c Appearance properties</em>
	///
	/// \sa IHotKeyBox::Appearance, IIPAddressBox::Appearance, ITextBox::Appearance,
	///     IUpDownTextBox::Appearance
	[helpstring("Constants used with the 'Appearance' properties.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight,
		/// \brief Let the control decide about the outer border style
		///
		/// \remarks This value can't be set at runtime and is valid for the \c HotKeyBox and \c IPAddressBox
		///          controls only.
		[helpstring("The control decides itself which border to draw. This value can't be set at runtime and is valid for the 'HotKeyBox' and 'IPAddressBox' controls only.")]
		aDefault
	} AppearanceConstants;

	/// \brief <em>Flags used with the \c AutoScrolling properties</em>
	///
	/// \sa ITextBox::AutoScrolling, IUpDownTextBox::AutoScrolling
	[helpstring("Flags used with the 'AutoScrolling' properties. They can be combined.")]
	typedef enum AutoScrollingConstants {
		/// \brief Don't scroll automatically if the user types a character at the end of the line or presses the \c ENTER key at the last line
		[helpstring("Don't scroll automatically if the user types a character at the end of the line or presses the ENTER key at the last line.")]
		asNone = 0,
		/// \brief Scroll automatically if the user presses the \c ENTER key at the last line
		[helpstring("Scroll automatically if the user presses the \c ENTER key at the last line.")]
		asVertical = 1,
		/// \brief Scroll automatically if the user types a character at the end of the line
		[helpstring("Scroll automatically if the user types a character at the end of the line.")]
		asHorizontal = 2
	} AutoScrollingConstants;

	/// \brief <em>Constants used with the \c ShowBalloonTip methods</em>
	///
	/// \sa ITextBox::ShowBalloonTip, IUpDownTextBox::ShowBalloonTip
	[helpstring("Constants used with the 'ShowBalloonTip' methods.")]
	typedef enum BalloonTipIconConstants {
		/// \brief Don't display any icon in the balloon tip
		[helpstring("Don't display any icon in the balloon tip.")]
		btiNone = 0/*TTI_NONE*/,
		/// \brief Display the information icon in the balloon tip
		[helpstring("Display the information icon in the balloon tip.")]
		btiInfo = 1/*TTI_INFO*/,
		/// \brief Display the warning icon in the balloon tip
		[helpstring("Display the warning icon in the balloon tip.")]
		btiWarning = 2/*TTI_WARNING*/,
		/// \brief Display the error icon in the balloon tip
		[helpstring("Display the error icon in the balloon tip.")]
		btiError = 3/*TTI_ERROR*/,
		/// \brief Display the large information icon in the balloon tip
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		[helpstring("Display the large information icon in the balloon tip. Requires comctl32.dll version 6.10 or higher.")]
		btiInfoLarge = 4/*TTI_INFO_LARGE*/,
		/// \brief Display the large warning icon in the balloon tip
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		[helpstring("Display the large warning icon in the balloon tip. Requires comctl32.dll version 6.10 or higher.")]
		btiWarningLarge = 5/*TTI_WARNING_LARGE*/,
		/// \brief Display the large error icon in the balloon tip
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		[helpstring("Display the large error icon in the balloon tip. Requires comctl32.dll version 6.10 or higher.")]
		btiErrorLarge = 6/*TTI_ERROR_LARGE*/
	} BalloonTipIconConstants;

	/// \brief <em>Constants used with the \c Base properties</em>
	///
	/// \sa IUpDownTextBox::Base
	[helpstring("Constants used with the 'Base' properties.")]
	typedef enum BaseConstants {
		/// \brief The contained edit control displays numbers in decimal digits
		[helpstring("The contained edit control displays numbers in decimal digits.")]
		bDecimal,
		/// \brief The contained edit control displays numbers in hexadecimal digits
		[helpstring("The contained edit control displays numbers in hexadecimal digits.")]
		bHexadecimal
	} BaseConstants;

	/// \brief <em>Constants used with the \c BorderStyle properties</em>
	///
	/// \sa IHotKeyBox::BorderStyle, IIPAddressBox::BorderStyle, ITextBox::BorderStyle,
	///     IUpDownTextBox::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' properties.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used with the \c CharacterConversion properties</em>
	///
	/// \sa ITextBox::CharacterConversion, IUpDownTextBox::CharacterConversion
	[helpstring("Constants used with the 'CharacterConversion' properties.")]
	typedef enum CharacterConversionConstants {
		/// \brief The control does not convert anything
		[helpstring("The control does not convert anything.")]
		ccNone,
		/// \brief The control converts all characters to lowercase as they are typed into the control
		[helpstring("The control converts all characters to lowercase as they are typed into the control.")]
		ccLowerCase,
		/// \brief The control converts all characters to uppercase as they are typed into the control
		[helpstring("The control converts all characters to uppercase as they are typed into the control.")]
		ccUpperCase
	} CharacterConversionConstants;

	/// \brief <em>Flags used with the \c DisabledEvents properties</em>
	///
	/// \sa IHotKeyBox::DisabledEvents, IIPAddressBox::DisabledEvents, ITextBox::DisabledEvents,
	///     IUpDownTextBox::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' properties. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MouseEnter, \c MouseHover,
		/// \c MouseLeave, \c MouseMove, \c MouseWheel
		///
		/// \sa _IHotKeyBoxEvents::MouseDown, _IHotKeyBoxEvents::MouseUp,
		///     _IHotKeyBoxEvents::MouseEnter, _IHotKeyBoxEvents::MouseHover,
		///     _IHotKeyBoxEvents::MouseLeave, _IHotKeyBoxEvents::MouseMove,
		///     _IHotKeyBoxEvents::MouseWheel,\n
		///     _IIPAddressBoxEvents::MouseDown, _IIPAddressBoxEvents::MouseUp,
		///     _IIPAddressBoxEvents::MouseEnter, _IIPAddressBoxEvents::MouseHover,
		///     _IIPAddressBoxEvents::MouseLeave, _IIPAddressBoxEvents::MouseMove,
		///     _IIPAddressBoxEvents::MouseWheel,\n
		///     _ITextBoxEvents::MouseDown, _ITextBoxEvents::MouseUp,
		///     _ITextBoxEvents::MouseEnter, _ITextBoxEvents::MouseHover,
		///     _ITextBoxEvents::MouseLeave, _ITextBoxEvents::MouseMove,
		///     _ITextBoxEvents::MouseWheel,\n
		///     _IUpDownTextBoxEvents::MouseDown, _IUpDownTextBoxEvents::MouseUp,
		///     _IUpDownTextBoxEvents::MouseEnter, _IUpDownTextBoxEvents::MouseHover,
		///     _IUpDownTextBoxEvents::MouseLeave, _IUpDownTextBoxEvents::MouseMove,
		///     _IUpDownTextBoxEvents::MouseWheel
		[helpstring("Disables the following events: MouseDown, MouseUp, MouseEnter, MouseHover, MouseLeave, MouseMove, MouseWheel")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _IHotKeyBoxEvents::Click, _IHotKeyBoxEvents::DblClick, _IHotKeyBoxEvents::MClick,
		///     _IHotKeyBoxEvents::MDblClick, _IHotKeyBoxEvents::RClick,
		///     _IHotKeyBoxEvents::RDblClick, _IHotKeyBoxEvents::XClick,
		///     _IHotKeyBoxEvents::XDblClick,\n
		///     _IIPAddressBoxEvents::Click, _IIPAddressBoxEvents::DblClick, _IIPAddressBoxEvents::MClick,
		///     _IIPAddressBoxEvents::MDblClick, _IIPAddressBoxEvents::RClick,
		///     _IIPAddressBoxEvents::RDblClick, _IIPAddressBoxEvents::XClick,
		///     _IIPAddressBoxEvents::XDblClick,\n
		///     _ITextBoxEvents::Click, _ITextBoxEvents::DblClick, _ITextBoxEvents::MClick,
		///     _ITextBoxEvents::MDblClick, _ITextBoxEvents::RClick,
		///     _ITextBoxEvents::RDblClick, _ITextBoxEvents::XClick,
		///     _ITextBoxEvents::XDblClick,\n
		///     _IUpDownTextBoxEvents::Click, _IUpDownTextBoxEvents::DblClick, _IUpDownTextBoxEvents::MClick,
		///     _IUpDownTextBoxEvents::MDblClick, _IUpDownTextBoxEvents::RClick,
		///     _IUpDownTextBoxEvents::RDblClick, _IUpDownTextBoxEvents::XClick,
		///     _IUpDownTextBoxEvents::XDblClick
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _IHotKeyBoxEvents::KeyDown, _IHotKeyBoxEvents::KeyUp, _IHotKeyBoxEvents::KeyPress,\n
		///     _IIPAddressBoxEvents::KeyDown, _IIPAddressBoxEvents::KeyUp, _IIPAddressBoxEvents::KeyPress,\n
		///     _ITextBoxEvents::KeyDown, _ITextBoxEvents::KeyUp, _ITextBoxEvents::KeyPress,\n
		///     _IUpDownTextBoxEvents::KeyDown, _IUpDownTextBoxEvents::KeyUp, _IUpDownTextBoxEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief The \c BeforeDrawText event won't be fired
		///
		/// The following event won't be fired: \c BeforeDrawText
		///
		/// \sa _ITextBoxEvents::BeforeDrawText\n
		///     _IUpDownTextBoxEvents::BeforeDrawText
		[helpstring("Disables the following event: BeforeDrawText")]
		deBeforeDrawText = 0x400,
		/// \brief The \c Scrolling event won't be fired
		///
		/// The following event won't be fired: \c Scrolling
		///
		/// \sa _ITextBoxEvents::Scrolling
		[helpstring("Disables the following event: Scrolling")]
		deScrolling = 0x800,
		/// \brief The \c FieldTextChanged and \c TextChanged events won't be fired
		///
		/// The following events won't be fired: \c FieldTextChanged, \c TextChanged
		///
		/// \sa _IIPAddressBoxEvents::FieldTextChanged,\n
		///     _ITextBoxEvents::TextChanged,\n
		///     _IUpDownTextBoxEvents::TextChanged
		[helpstring("Disables the following events: FieldTextChanged, TextChanged")]
		deTextChangedEvents = 0x1000,
		/// \brief Events concerning value changes won't be fired
		///
		/// The following events won't be fired: \c ValueChanging, \c ValueChanged
		///
		/// \sa _IUpDownTextBoxEvents::ValueChanging, _IUpDownTextBoxEvents::ValueChanged
		[helpstring("Disables the following events: ValueChanging, ValueChanged")]
		deValueChangingEvents = 0x2000
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _IHotKeyBoxEvents::MouseDown, _IHotKeyBoxEvents::MouseEnter, _IHotKeyBoxEvents::MouseHover,
	///     _IHotKeyBoxEvents::MouseLeave, _IHotKeyBoxEvents::MouseMove, _IHotKeyBoxEvents::MouseUp,
	///     _IHotKeyBoxEvents::XClick, _IHotKeyBoxEvents::XDblClick,
	///     _IIPAddressBoxEvents::MouseDown, _IIPAddressBoxEvents::MouseEnter,
	///     _IIPAddressBoxEvents::MouseHover, _IIPAddressBoxEvents::MouseLeave,
	///     _IIPAddressBoxEvents::MouseMove, _IIPAddressBoxEvents::MouseUp,
	///     _IIPAddressBoxEvents::XClick, _IIPAddressBoxEvents::XDblClick
	///     _ITextBoxEvents::MouseDown, _ITextBoxEvents::MouseEnter, _ITextBoxEvents::MouseHover,
	///     _ITextBoxEvents::MouseLeave, _ITextBoxEvents::MouseMove, _ITextBoxEvents::MouseUp,
	///     _ITextBoxEvents::XClick, _ITextBoxEvents::XDblClick,
	///     _IUpDownTextBoxEvents::MouseDown, _IUpDownTextBoxEvents::MouseEnter,
	///     _IUpDownTextBoxEvents::MouseHover, _IUpDownTextBoxEvents::MouseLeave,
	///     _IUpDownTextBoxEvents::MouseMove, _IUpDownTextBoxEvents::MouseUp,
	///     _IUpDownTextBoxEvents::XClick, _IUpDownTextBoxEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Constants used with the \c HAlignment properties</em>
	///
	/// \sa ITextBox::HAlignment, IUpDownTextBox::HAlignment
	[helpstring("Constants used with the 'HAlignment' properties.")]
	typedef enum HAlignmentConstants {
		/// \brief The control's content is left-aligned
		[helpstring("The control's content is left-aligned.")]
		halLeft,
		/// \brief The control's content is horizontally centered
		[helpstring("The control's content is horizontally centered.")]
		halCenter,
		/// \brief The control's content is right-aligned
		[helpstring("The control's content is right-aligned.")]
		halRight
	} HAlignmentConstants;

	/// \brief <em>Constants used with the \c IUpDownTextBox::HitTest method</em>
	///
	/// \sa IUpDownTextBox::HitTest
	[helpstring("Constants used with the 'UpDownTextBox.HitTest' method.")]
	typedef enum HitTestConstants {
		/// \brief Not over the control's client area
		///
		/// The specified point lies not over the up down text box control's client area.
		[helpstring("The specified point lies not over the up down text box control's client area.")]
		htNotOverControl,
		/// \brief On the text box portion
		///
		/// The specified point lies on the up down text box control's text box portion.
		[helpstring("The specified point lies on the up down text box control's text box portion.")]
		htTextBox,
		/// \brief On the up down portion
		///
		/// The specified point lies on the up down text box control's up down portion.
		[helpstring("The specified point lies on the up down text box control's up down portion.")]
		htUpDown
	} HitTestConstants;

	/// \brief <em>Constants used with the \c IMEMode properties</em>
	///
	/// \sa IIPAddressBox::IMEMode, ITextBox::IMEMode, IUpDownTextBox::IMEMode
	[helpstring("Constants used with the 'IMEMode' properties.")]
	typedef enum IMEModeConstants {
		/// \brief Use the same IME settings as the control's parent
		[helpstring("Inherit the IME status from the control's parent.")]
		imeInherit = -1,
		/// \brief Don't change anything on the control's default IME settings
		[helpstring("Leaves the control's IME status untouched.")]
		imeNoControl = 0,
		/// \brief Set the control's IME status to "on"
		[helpstring("Sets the control's IME status to \"on\".")]
		imeOn = 1,
		/// \brief Set the control's IME status to "off"
		[helpstring("Sets the control's IME status to \"off\".")]
		imeOff = 2,
		/// \brief Don't use IME
		[helpstring("Disables IME for the control.")]
		imeDisable = 3,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Hiragana Double-Byte Characters\" (Japanese IME only).")]
		imeHiragana = 4,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Double-Byte Characters\" (Japanese IME only).")]
		imeKatakana = 5,
		/// \brief Set the control's IME status to "Katakana Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Single-Byte Characters\" (Japanese IME only).")]
		imeKatakanaHalf = 6,
		/// \brief Set the control's IME status to "Alphanumeric Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Double-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlphaFull = 7,
		/// \brief Set the control's IME status to "Alphanumeric Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Single-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlpha = 8,
		/// \brief Set the control's IME status to "Hangul Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Single-Byte Characters\" (Korean IME only).")]
		imeHangulFull = 9,
		/// \brief Set the control's IME status to "Hangul Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Double-Byte Characters\" (Korean IME only).")]
		imeHangul = 10
	} IMEModeConstants;

	/// \brief <em>Constants that may be used with the \c TextBox::SetInsertMarkPosition and \c TextBox::GetInsertMarkPosition methods</em>
	///
	/// Constants that may be used for the \c relativePosition parameter of the
	/// \c TextBox::SetInsertMarkPosition and \c TextBox::GetInsertMarkPosition methods.
	///
	/// \sa ITextBox::SetInsertMarkPosition, ITextBox::GetInsertMarkPosition
	[helpstring("Constants that may be used for the 'relativePosition' parameter of the 'TextBox.SetInsertMarkPosition' and 'TextBox.GetInsertMarkPosition' methods.")]
	typedef enum InsertMarkPositionConstants {
		/// \brief The insertion mark is or will be removed
		[helpstring("The insertion mark is or will be removed.")]
		impNowhere = 0,
		/// \brief The insertion mark is or will be placed before the character
		[helpstring("The insertion mark is or will be placed before the character.")]
		impBefore = 1,
		/// \brief The insertion mark is or will be placed after the character
		[helpstring("The insertion mark is or will be placed after the character.")]
		impAfter = 2,
		/// \brief The insertion mark won't be (re-)moved
		[helpstring("The insertion mark won't be (re-)moved.")]
		impDontChange = 3
	} InsertMarkPositionConstants;

	/// \brief <em>Flags used with the \c IHotKeyBox::InvalidKeyCombinations property</em>
	///
	/// \sa IHotKeyBox::InvalidKeyCombinations
	[helpstring("Flags used with the 'HotKeyBox.InvalidKeyCombinations' property. They can be combined.")]
	typedef enum InvalidKeyCombinationsConstants {
		/// \brief Key combinations that no modifier key is involved in, are invalid
		[helpstring("Key combinations that no modifier key is involved in, are invalid.")]
		ikcUnmodifiedKeys = 0x0001/*HKCOMB_NONE*/,
		/// \brief Key combinations of the form [SHIFT]+ are invalid
		[helpstring("Key combinations of the form [SHIFT]+ are invalid.")]
		ikcShiftPlusKey = 0x0002/*HKCOMB_S*/,
		/// \brief Key combinations of the form [CTRL]+ are invalid
		[helpstring("Key combinations of the form [CTRL]+ are invalid.")]
		ikcCtrlPlusKey = 0x0004/*HKCOMB_C*/,
		/// \brief Key combinations of the form [ALT]+ are invalid
		[helpstring("Key combinations of the form [ALT]+ are invalid.")]
		ikcAltPlusKey = 0x0008/*HKCOMB_A*/,
		/// \brief Key combinations of the form [SHIFT]+[CTRL]+ are invalid
		[helpstring("Key combinations of the form [SHIFT]+[CTRL]+ are invalid.")]
		ikcShiftPlusCtrlPlusKey = 0x0010/*HKCOMB_SC*/,
		/// \brief Key combinations of the form [SHIFT]+[ALT]+ are invalid
		[helpstring("Key combinations of the form [SHIFT]+[ALT]+ are invalid.")]
		ikcShiftPlusAltPlusKey = 0x0020/*HKCOMB_SA*/,
		/// \brief Key combinations of the form [CTRL]+[ALT]+ are invalid
		[helpstring("Key combinations of the form [CTRL]+[ALT]+ are invalid.")]
		ikcCtrlPlusAltPlusKey = 0x0040/*HKCOMB_CA*/,
		/// \brief Key combinations of the form [SHIFT]+[CTRL]+[ALT]+ are invalid
		[helpstring("Key combinations of the form [SHIFT]+[CTRL]+[ALT]+ are invalid.")]
		ikcShiftPlusCtrlPlusAltPlusKey = 0x0080/*HKCOMB_SCA*/
	} InvalidKeyCombinationsConstants;

	/// \brief <em>Flags used with the \c IHotKeyBox::DefaultModifierKeys property and the \c IHotKeyBox::GetCurrentKeyCombination and \c IHotKeyBox::SetCurrentKeyCombination methods</em>
	///
	/// \sa IHotKeyBox::DefaultModifierKeys, IHotKeyBox::GetCurrentKeyCombination, IHotKeyBox::SetCurrentKeyCombination
	[helpstring("Flags used with the 'HotKeyBox.DefaultModifierKeys' property and the 'HotKeyBox.GetCurrentKeyCombination' and 'HotKeyBox.SetCurrentKeyCombination' methods. They can be combined.")]
	typedef enum ModifierKeysConstants {
		/// \brief The combination of modifier keys contains the [SHIFT] key
		[helpstring("The combination of modifier keys contains the [SHIFT] key.")]
		mkShift = 0x01/*HOTKEYF_SHIFT*/,
		/// \brief The combination of modifier keys contains the [CTRL] key
		[helpstring("The combination of modifier keys contains the [CTRL] key.")]
		mkCtrl = 0x02/*HOTKEYF_CONTROL*/,
		/// \brief The combination of modifier keys contains the [ALT] key
		[helpstring("The combination of modifier keys contains the [ALT] key.")]
		mkAlt = 0x04/*HOTKEYF_ALT*/,
		/// \brief The combination of modifier keys contains the extended key
		[helpstring("The combination of modifier keys contains the extended key.")]
		mkExt = 0x08/*HOTKEYF_EXT*/
	} ModifierKeysConstants;

	/// \brief <em>Constants used with the \c MousePointer properties</em>
	///
	/// \sa IHotKeyBox::MousePointer, IIPAddressBox::MousePointer, ITextBox::MousePointer,
	///     ITextBox::SelectedTextMousePointer, IUpDownTextBox::MousePointer
	[helpstring("Constants used with the 'MousePointer' properties.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with the \c OLEQueryContinueDrag event</em>
	///
	/// \sa _ITextBoxEvents::OLEQueryContinueDrag, _ITextBoxEvents::OLEGiveFeedback,
	///     ITextBox::OLEDrag
	[helpstring("Constants used with the OLEQueryContinueDrag event.")]
	typedef enum OLEActionToContinueWithConstants {
		/// \brief Continue the drag'n'drop operation
		[helpstring("Continue the drag'n'drop operation.")]
		oatcwContinue = 0x0 /*S_OK*/,
		/// \brief Cancel the drag'n'drop operation
		[helpstring("Cancel the drag'n'drop operation.")]
		oatcwCancel = 0x40101 /*DRAGDROP_S_CANCEL*/,
		/// \brief Complete the drag'n'drop operation
		[helpstring("Complete the drag'n'drop operation.")]
		oatcwDrop = 0x40100 /*DRAGDROP_S_DROP*/
	} OLEActionToContinueWithConstants;

	/// \brief <em>Constants used with the \c OLEDragImageStyle property</em>
	///
	/// \sa ITextBox::OLEDragImageStyle
	[helpstring("Constants used with the 'OLEDragImageStyle' property.")]
	typedef enum OLEDragImageStyleConstants {
		/// \brief OLE drag images will be generated in classic style
		[helpstring("OLE drag images will be generated in classic style.")]
		odistClassic,
		/// \brief OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems
		///
		/// \remarks Aero style is supported by Windows Vista and newer systems.
		[helpstring("OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems. Aero style is supported by Windows Vista and newer systems.")]
		odistAeroIfAvailable
	} OLEDragImageStyleConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _IHotKeyBoxEvents::OLEDragEnter, _IHotKeyBoxEvents::OLEDragMouseMove,
	///     _IHotKeyBoxEvents::OLEDragDrop,\n
	///     _IIPAddressBoxEvents::OLEDragEnter, _IIPAddressBoxEvents::OLEDragMouseMove,
	///     _IIPAddressBoxEvents::OLEDragDrop,\n
	///     _ITextBoxEvents::OLEDragEnter, _ITextBoxEvents::OLEDragMouseMove,
	///     _ITextBoxEvents::OLEDragDrop,\n
	///     _IUpDownTextBoxEvents::OLEDragEnter, _IUpDownTextBoxEvents::OLEDragMouseMove,
	///     _IUpDownTextBoxEvents::OLEDragDrop
	[helpstring("Constants used with the OLEDrag* events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Constants used with the \c IUpDownTextBox::Orientation property</em>
	///
	/// \sa IUpDownTextBox::Orientation
	[helpstring("Constants used with the 'UpDownTextBox.Orientation' property.")]
	typedef enum OrientationConstants {
		/// \brief The control is orientated horizontally
		[helpstring("The control is orientated horizontally.")]
		oHorizontal,
		/// \brief The control is orientated vertically
		[helpstring("The control is orientated vertically.")]
		oVertical
	} OrientationConstants;

	/// \brief <em>Flags used with the \c RightToLeft properties</em>
	///
	/// \sa IHotKeyBox::RightToLeft, ITextBox::RightToLeft, IUpDownTextBox::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' properties. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The control's text is read from right to left, but the general layout is left to right.
		[helpstring("The control's text is read from right to left, but the general layout is left to right.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left.
		[helpstring("The general layout is right to left.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Flags used with the \c ITextBox::Scroll method and the \c _ITextBoxEvents::Scrolling and MouseWheel events</em>
	///
	/// \sa _IHotKeyBoxEvents::MouseWheel, _IIPAddressBoxEvents::MouseWheel, ITextBox::Scroll,
	///     _ITextBoxEvents::Scrolling, _ITextBoxEvents::MouseWheel, _IUpDownTextBoxEvents::MouseWheel
	[helpstring("Flags used with the 'TextBox.Scroll' method and the 'TextBox.Scrolling' and 'MouseWheel' events. For 'TextBox.Scroll', they can be combined.")]
	typedef enum ScrollAxisConstants {
		/// \brief Scroll vertically
		[helpstring("The control will scroll vertically.")]
		saVertical = 1,
		/// \brief Scroll horizontally
		[helpstring("The control will scroll horizontally.")]
		saHorizontal = 2
	} ScrollAxisConstants;

	/// \brief <em>Flags used with the \c ITextBox::ScrollBars property</em>
	///
	/// \sa ITextBox::ScrollBars
	[helpstring("Flags used with the 'TextBox.ScrollBars' property. They can be combined.")]
	typedef enum ScrollBarsConstants {
		/// \brief Don't display any scrollbars
		[helpstring("The control doesn't display any scrollbars.")]
		sbNone = 0,
		/// \brief Display a vertical scrollbar
		[helpstring("The control displays a vertical scrollbar.")]
		sbVertical = 1,
		/// \brief Display a horizontal scrollbar
		[helpstring("The control displays a horizontal scrollbar.")]
		sbHorizontal = 2
	} ScrollBarsConstants;

	/// \brief <em>Constants used with the \c ITextBox::Scroll method</em>
	///
	/// \sa ITextBox::Scroll
	[helpstring("Constants used with the 'TextBox.Scroll' method.")]
	typedef enum ScrollDirectionConstants {
		/// \brief Scrolls up by one line or left by one unit
		[helpstring("The control will scroll up by one line or left by one unit.")]
		sdLineUpOrLeft = 0/*SB_LINEUP, SB_LINELEFT*/,
		/// \brief Scrolls down by one line or right by one unit
		[helpstring("The control will scroll down by one line or right by one unit.")]
		sdLineDownOrRight = 1/*SB_LINEDOWN, SB_LINERIGHT*/,
		/// \brief Scrolls up by one page or left by one window width
		[helpstring("The control will scroll up by one page or left by one window width.")]
		sdPageUpOrLeft = 2/*SB_PAGEUP, SB_PAGELEFT*/,
		/// \brief Scrolls down by one page or right by one window width
		[helpstring("The control will scroll down by one page or right by one window width.")]
		sdPageDownOrRight = 3/*SB_PAGEDOWN, SB_PAGERIGHT*/,
		/// \brief Scrolls to the control's upper left
		[helpstring("The control will scroll to the control's upper left.")]
		sdTopOrLeft = 6/*SB_TOP, SB_LEFT*/,
		/// \brief Scrolls to the control's lower right
		[helpstring("The control will scroll to the control's lower right.")]
		sdBottomOrRight = 7/*SB_BOTTOM, SB_RIGHT*/,
		/// \brief Scrolls by the values specified by the \c linesToScrollVertically and \c charactersToScrollHorizontally parameters
		[helpstring("Scrolls by the values specified by the 'linesToScrollVertically' and 'charactersToScrollHorizontally' parameters.")]
		sdCustom = 99
	} ScrollDirectionConstants;

	/// \brief <em>Constants used with the \c IUpDownTextBox::UpDownPosition property</em>
	///
	/// \sa IUpDownTextBox::UpDownPosition
	[helpstring("Constants used with the 'UpDownTextBox.UpDownPosition' property.")]
	typedef enum UpDownPositionConstants {
		/// \brief The up down control is placed to the left of the textbox
		[helpstring("The up down control is placed to the left of the textbox.")]
		udLeftOfTextBox,
		/// \brief The up down control is placed to the right of the textbox
		[helpstring("The up down control is placed to the right of the textbox.")]
		udRightOfTextBox
	} UpDownPositionConstants;

	/// \brief <em>Constants used with the \c WritingDirectionChanged events</em>
	///
	/// \sa _ITextBoxEvents::WritingDirectionChanged, _IUpDownTextBoxEvents::WritingDirectionChanged
	[helpstring("Constants used with the 'WritingDirectionChanged' events.")]
	typedef enum WritingDirectionConstants {
		/// \brief The writing direction is left-to-right
		[helpstring("The writing direction is left-to-right.")]
		wdLeftToRight,
		/// \brief The writing direction is right-to-left
		[helpstring("The writing direction is right-to-left.")]
		wdRightToLeft
	} WritingDirectionConstants;


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(2217C934-5CAD-415a-9130-E1A4A1CB71CC),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, IHotKeyBox::SupportOLEDragImages, IIPAddressBox::SupportOLEDragImages,
		///     ITextBox::SupportOLEDragImages, IUpDownTextBox::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear, _ITextBoxEvents::OLESetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, IHotKeyBox::SupportOLEDragImages, IIPAddressBox::SupportOLEDragImages,
		///     ITextBox::SupportOLEDragImages, IUpDownTextBox::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(FBC32A63-2854-4282-8395-63F2B60A9A1A),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(2A87ADA9-8CDB-4bfc-A4A9-F781753BC26D),
		version(1.10),
		noncreatable,
		helpstring("OLEDataObject Class 1.10 (Unicode)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	/// \interface IHotKeyBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the hot key control's main interface. It wraps the control window.
	///
	/// \sa _IHotKeyBoxEvents
	[
		object,
		uuid(0991AD42-066F-4f45-89FB-02EFBAF5A72A),
		dual,
		nonextensible,
		helpstring("IHotKeyBox interface"),
		pointer_default(unique)
	]
	interface IHotKeyBox : IDispatch
	{
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_HKBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_HKBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa DisabledBackColor
		[propget, id(DISPID_HKBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_HKBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_HKBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_HKBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the automatic correction of invalid key combinations</em>
		///
		/// Retrieves or sets the combination of modifier keys, that is used automatically if the user enters
		/// an invalid key combination. Any combination of the values defined by the \c ModifierKeysConstants
		/// enumeration is valid.
		///
		/// \sa InvalidKeyCombinations, ModifierKeysConstants
		[propget, id(DISPID_HKBOX_DEFAULTMODIFIERKEYS), helpstring("Retrieves or sets the combination of modifier keys, that is used automatically if the user enters an invalid key combination."), nonbrowsable]
		HRESULT DefaultModifierKeys([out, retval] ModifierKeysConstants* pValue);
		[propput, id(DISPID_HKBOX_DEFAULTMODIFIERKEYS), helpstring("Retrieves or sets the combination of modifier keys, that is used automatically if the user enters an invalid key combination."), nonbrowsable]
		HRESULT DefaultModifierKeys([in] ModifierKeysConstants newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the color used as the control's background color, if the control is disabled. If
		/// set to -1, the system's default color is used.
		///
		/// \sa Enabled, BackColor
		[propget, id(DISPID_HKBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is disabled.")]
		HRESULT DisabledBackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_HKBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is disabled.")]
		HRESULT DisabledBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_HKBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_HKBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_HKBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_HKBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, Text
		[propget, id(DISPID_HKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_HKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_HKBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IHotKeyBoxEvents::MouseHover
		[propget, id(DISPID_HKBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_HKBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IHotKeyBoxEvents::RecreatedControlWindow, _IHotKeyBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_HKBOX_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the kinds of key combinations that are handled as invalid</em>
		///
		/// Retrieves or sets the types of key combinations, that the control won't accept. Any combination of
		/// the values defined by the \c InvalidKeyCombinationsConstants enumeration is valid.
		///
		/// \sa DefaultModifierKeys, InvalidKeyCombinationsConstants
		[propget, id(DISPID_HKBOX_INVALIDKEYCOMBINATIONS), helpstring("Retrieves or sets the types of key combinations, that the control won't accept."), nonbrowsable]
		HRESULT InvalidKeyCombinations([out, retval] InvalidKeyCombinationsConstants* pValue);
		[propput, id(DISPID_HKBOX_INVALIDKEYCOMBINATIONS), helpstring("Retrieves or sets the types of key combinations, that the control won't accept."), nonbrowsable]
		HRESULT InvalidKeyCombinations([in] InvalidKeyCombinationsConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_HKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_HKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_HKBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_HKBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_HKBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IHotKeyBoxEvents::ContextMenu
		[propget, id(DISPID_HKBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_HKBOX_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IHotKeyBoxEvents::OLEDragEnter
		[propget, id(DISPID_HKBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_HKBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_HKBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_HKBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_HKBOX_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the current key combination as a string</em>
		///
		/// Retrieves a (localized) string representation of the key combination currently displayed by the
		/// control.
		///
		/// \remarks This is the control's default property.\n
		///          This property is read-only.
		///
		/// \sa Font
		[propget, id(DISPID_HKBOX_TEXT), helpstring("Retrieves a (localized) string representation of the key combination currently displayed by the control."), nonbrowsable]
		HRESULT Text([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_HKBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_HKBOX_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_HKBOX_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Retrieves the current key combination displayed by the control</em>
		///
		/// \param[out] modifierKeys The modifier keys that are part of the key combination. Any combination of
		///             the values defined by the \c ModifierKeysConstants enumeration is valid.
		/// \param[out] keyCode The virtual key code of the key that the key combination is based on.
		///
		/// \sa SetCurrentKeyCombination, ModifierKeysConstants
		[id(DISPID_HKBOX_GETCURRENTKEYCOMBINATION), helpstring("Retrieves the current key combination displayed by the control.")]
		HRESULT GetCurrentKeyCombination([in, out, defaultvalue(0)] ModifierKeysConstants* modifierKeys, [in, out, defaultvalue(0)] BYTE* keyCode);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_HKBOX_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_HKBOX_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_HKBOX_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Sets the key combination displayed by the control</em>
		///
		/// \param[in] modifierKeys The modifier keys that are part of the key combination. Any combination of
		///            the values defined by the \c ModifierKeysConstants enumeration is valid.
		/// \param[in] keyCode The virtual key code of the key that the key combination is based on.
		///
		/// \remarks Setting \c modifierKeys and \c keyCode to 0 clears the key combination.
		///
		/// \sa GetCurrentKeyCombination, ModifierKeysConstants
		[id(DISPID_HKBOX_SETCURRENTKEYCOMBINATION), helpstring("Sets the key combination displayed by the control.")]
		HRESULT SetCurrentKeyCombination([in] ModifierKeysConstants modifierKeys, [in] BYTE keyCode);

		/// \brief <em>Specifies whether the control intercepts double clicks</em>
		///
		/// Enables or disables double clicks. If set to \c True, double clicks are accepted; otherwise all
		/// clicks are handled as single clicks.
		///
		/// \sa _IHotKeyBoxEvents::DblClick, _IHotKeyBoxEvents::MDblClick, _IHotKeyBoxEvents::RDblClick,
		///     _IHotKeyBoxEvents::XDblClick
		[propget, id(DISPID_HKBOX_DETECTDOUBLECLICKS), helpstring("Enables or disables double clicks.")]
		HRESULT DetectDoubleClicks([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_HKBOX_DETECTDOUBLECLICKS), helpstring("Enables or disables double clicks.")]
		HRESULT DetectDoubleClicks([in] VARIANT_BOOL newValue);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IHotKeyBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_HKBOX_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IHotKeyBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c HotKeyBox class' events interface</em>
	///
	/// This interface defines all events the \c HotKeyBox class may raise.
	///
	/// \sa IHotKeyBox
	[
		uuid(F2BD3858-22AC-4d62-A194-1CC00C25B782),
		helpstring("IHotKeyBox-event-interface")
	]
	dispinterface _IHotKeyBoxEvents
	{
		properties:
		methods:
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks This is the control's default event.\n
			///          You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			///
			/// \sa RClick
			[id(DISPID_HKBOXE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, IHotKeyBox::DetectDoubleClicks,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IHotKeyBox::hWnd
			[id(DISPID_HKBOXE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, IHotKeyBox::DetectDoubleClicks,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ITextBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IHotKeyBox::HoverTime, ExtendedMouseButtonConstants,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ExtendedMouseButtonConstants,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, ScrollAxisConstants, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IHotKeyBox::RegisterForOLEDragDrop,
			///     IHotKeyBox::FinishOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_HKBOXE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, IHotKeyBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_HKBOXE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, IHotKeyBox::RegisterForOLEDragDrop
			[id(DISPID_HKBOXE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IHotKeyBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_HKBOXE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, IHotKeyBox::DetectDoubleClicks,
			///     IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IHotKeyBox::hWnd
			[id(DISPID_HKBOXE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_HKBOXE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     IHotKeyBox::DetectDoubleClicks, IHotKeyBox::DisabledEvents
			[id(DISPID_HKBOXE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c HotKeyBox class</em>
	///
	/// The control's main COM class. It implements the \c IHotKeyBox and
	/// \c _IHotKeyBoxEvents interfaces.
	///
	/// \sa IHotKeyBox, _IHotKeyBoxEvents
	[
		uuid(7E32007E-7379-466e-9717-7249001F8E09),
		version(1.10),
		helpstring("HotKeyBox Control 1.10 (Unicode)")
	]
	coclass HotKeyBox
	{
		[default] interface IHotKeyBox;
		[default, source] dispinterface _IHotKeyBoxEvents;
	};


	/// \interface IIPAddressBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the IP address control's main interface. It wraps the control window.
	///
	/// \sa _IIPAddressBoxEvents
	[
		object,
		uuid(71FB0339-BF24-4bfe-8022-6FB378CDA01C),
		dual,
		nonextensible,
		helpstring("IIPAddressBox interface"),
		pointer_default(unique)
	]
	interface IIPAddressBox : IDispatch
	{
		/// \brief <em>Specifies the displayed IP address</em>
		///
		/// Retrieves or sets the currently displayed IP address. Setting this property to an empty string
		/// clears the displayed address.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa ForeColor, Font, _IIPAddressBoxEvents::AddressChanged
		[propget, id(DISPID_IPADDRBOX_ADDRESS), helpstring("Retrieves or sets the currently displayed IP address.")]
		HRESULT Address([out, retval] BSTR* pValue);
		[propput, id(DISPID_IPADDRBOX_ADDRESS), helpstring("Retrieves or sets the currently displayed IP address.")]
		HRESULT Address([in] BSTR newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_IPADDRBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_IPADDRBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa ForeColor, DisabledBackColor
		[propget, id(DISPID_IPADDRBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_IPADDRBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_IPADDRBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_IPADDRBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the color used as the control's background color, if the control is disabled. If
		/// set to -1, the system's default color is used.
		///
		/// \sa Enabled, BackColor
		[propget, id(DISPID_IPADDRBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is disabled.")]
		HRESULT DisabledBackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_IPADDRBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is disabled.")]
		HRESULT DisabledBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_IPADDRBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_IPADDRBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_IPADDRBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_IPADDRBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, ForeColor, Address
		[propget, id(DISPID_IPADDRBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_IPADDRBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_IPADDRBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor
		[propget, id(DISPID_IPADDRBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_IPADDRBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IIPAddressBoxEvents::MouseHover
		[propget, id(DISPID_IPADDRBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_IPADDRBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndEdit, _IIPAddressBoxEvents::RecreatedControlWindow,
		///     _IIPAddressBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_IPADDRBOX_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves a contained edit control's window handle</em>
		///
		/// Retrieves the window handle of the specified contained edit control.
		///
		/// \param[in] index The one-based index of the edit control to retrieve the window handle for.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd
		[propget, id(DISPID_IPADDRBOX_HWNDEDIT), helpstring("Retrieves the window handle of the specified contained edit control."), nonbrowsable]
		HRESULT hWndEdit([in] LONG Index, [out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_IPADDRBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_IPADDRBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies a field's maximum value</em>
		///
		/// Retrieves or sets the maximum value that the specified field accepts.
		///
		/// \param[in] index The one-based index of the edit control that the property applies to.
		///
		/// \sa Minimum, Address
		[propget, id(DISPID_IPADDRBOX_MAXIMUM), helpstring("Retrieves or sets the maximum value that the specified field accepts."), nonbrowsable]
		HRESULT Maximum([in] LONG Index, [out, retval] BYTE* pValue);
		[propput, id(DISPID_IPADDRBOX_MAXIMUM), helpstring("Retrieves or sets the maximum value that the specified field accepts."), nonbrowsable]
		HRESULT Maximum([in] LONG Index, [in] BYTE newValue);
		/// \brief <em>Specifies a field's minimum value</em>
		///
		/// Retrieves or sets the minimum value that the specified field accepts.
		///
		/// \param[in] index The one-based index of the edit control that the property applies to.
		///
		/// \sa Maximum, Address
		[propget, id(DISPID_IPADDRBOX_MINIMUM), helpstring("Retrieves or sets the minimum value that the specified field accepts."), nonbrowsable]
		HRESULT Minimum([in] LONG Index, [out, retval] BYTE* pValue);
		[propput, id(DISPID_IPADDRBOX_MINIMUM), helpstring("Retrieves or sets the minimum value that the specified field accepts."), nonbrowsable]
		HRESULT Minimum([in] LONG Index, [in] BYTE newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_IPADDRBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_IPADDRBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_IPADDRBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_IPADDRBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_IPADDRBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IIPAddressBoxEvents::ContextMenu
		[propget, id(DISPID_IPADDRBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_IPADDRBOX_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IIPAddressBoxEvents::OLEDragEnter
		[propget, id(DISPID_IPADDRBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_IPADDRBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_IPADDRBOX_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_IPADDRBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_IPADDRBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_IPADDRBOX_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_IPADDRBOX_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_IPADDRBOX_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_IPADDRBOX_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_IPADDRBOX_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Sets the keyboard focus to the specified contained edit control</em>
		///
		/// \param[in] index The one-based index of the contained edit control to move the keyboard focus to.
		///            If set to -1, the focus is set to the first blank field.
		///
		/// \sa hWndEdit
		[id(DISPID_IPADDRBOX_SETFOCUSTOFIELD), helpstring("Sets the keyboard focus to the specified contained edit control.")]
		HRESULT SetFocusToField(LONG Index);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IIPAddressBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_IPADDRBOX_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IIPAddressBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c IPAddressBox class' events interface</em>
	///
	/// This interface defines all events the \c IPAddressBox class may raise.
	///
	/// \sa IIPAddressBox
	[
		uuid(6AD4647D-5C36-46de-BC74-FA38D6F55AF8),
		helpstring("IIPAddressBox-event-interface")
	]
	dispinterface _IIPAddressBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The IP address displayed by the control has been changed</em>
			///
			/// Will be fired after the IP address displayed by the control has been changed.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control whose content has been
			///            changed. If set to 0, all fields have been changed.
			/// \param[in,out] newFieldValue The specified IP address field's new value. You may change this
			///                value. If \c editBoxIndex is 0, this parameter is ignored.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa IIPAddressBox::Address, FieldTextChanged
			[id(DISPID_IPADDRBOXE_ADDRESSCHANGED), helpstring("Will be fired after the IP address displayed by the control has been changed.")]
			void AddressChanged(LONG editBoxIndex, LONG* newFieldValue);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick
			[id(DISPID_IPADDRBOXE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IIPAddressBox::hWnd
			[id(DISPID_IPADDRBOXE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The text of one of the contained edit controls was changed</em>
			///
			/// Will be fired after the content of one of the contained edit controls was changed.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control whose content has been
			///            changed. If set to 0, all fields have been changed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa AddressChanged
			[id(DISPID_IPADDRBOXE_FIELDTEXTCHANGED), helpstring("Will be fired after the content of one of the contained edit controls was changed. This event may be disabled.")]
			void FieldTextChanged(LONG editBoxIndex);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(LONG editBoxIndex, SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(LONG editBoxIndex, SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(LONG editBoxIndex, SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ITextBox::HoverTime property.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IIPAddressBox::HoverTime, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, ScrollAxisConstants, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IIPAddressBox::RegisterForOLEDragDrop,
			///     IIPAddressBox::FinishOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_IPADDRBOXE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(LONG editBoxIndex, IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter,
			///     IIPAddressBox::RegisterForOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_IPADDRBOXE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(LONG editBoxIndex, IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave,
			///     IIPAddressBox::RegisterForOLEDragDrop
			[id(DISPID_IPADDRBOXE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(LONG editBoxIndex, IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IIPAddressBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants
			[id(DISPID_IPADDRBOXE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(LONG editBoxIndex, IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IIPAddressBox::hWnd
			[id(DISPID_IPADDRBOXE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_IPADDRBOXE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] editBoxIndex The one-based index of the contained edit control this event is raised
			///            for. Will be 0 if the event is raised for the control itself.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     IIPAddressBox::DisabledEvents
			[id(DISPID_IPADDRBOXE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(LONG editBoxIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c IPAddressBox class</em>
	///
	/// The control's main COM class. It implements the \c IIPAddressBox and
	/// \c _IIPAddressBoxEvents interfaces.
	///
	/// \sa IIPAddressBox, _IIPAddressBoxEvents
	[
		uuid(235CD618-6B7F-4075-ADEF-057A8EF6A7CF),
		version(1.10),
		helpstring("IPAddressBox Control 1.10 (Unicode)")
	]
	coclass IPAddressBox
	{
		[default] interface IIPAddressBox;
		[default, source] dispinterface _IIPAddressBoxEvents;
	};


	/// \interface ITextBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the textbox control's main interface. It wraps the control window.
	///
	/// \sa _ITextBoxEvents
	[
		object,
		uuid(B7BBB25E-651A-4fc7-97DB-529B84CFE063),
		dual,
		nonextensible,
		helpstring("ITextBox interface"),
		pointer_default(unique)
	]
	interface ITextBox : IDispatch
	{
		/// \brief <em>Specifies whether the control accepts numbers only</em>
		///
		/// Retrieves or sets whether the control accepts all kind of text or only numbers. If set to \c True,
		/// only numbers, otherwise all text is accepted.
		///
		/// \sa Text
		[propget, id(DISPID_TXTBOX_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control processes the [TAB] key</em>
		///
		/// Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control. If set to
		/// \c True, a tabulator is inserted; otherwise the keyboard focus is transfered to the next control.
		///
		/// \sa TabStops, TabWidth, Text, _ITextBoxEvents::KeyDown
		[propget, id(DISPID_TXTBOX_ACCEPTTABKEY), helpstring("Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control.")]
		HRESULT AcceptTabKey([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_ACCEPTTABKEY), helpstring("Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control.")]
		HRESULT AcceptTabKey([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control detects drag'n'drop operations</em>
		///
		/// Retrieves or sets whether drag'n'drop mode can be entered. If set to \c True, drag'n'drop mode
		/// can be entered by pressing the left or right mouse button over selected text and then moving the
		/// mouse with the button still pressed. If set to \c False, drag'n'drop mode is not available - this
		/// also means the \c BeginDrag and \c BeginRDrag events don't get fired.
		///
		/// \sa RegisterForOLEDragDrop, DragScrollTimeBase, SetInsertMarkPosition, _ITextBoxEvents::BeginDrag,
		///     _ITextBoxEvents::BeginRDrag
		[propget, id(DISPID_TXTBOX_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how selected text is displayed</em>
		///
		/// Retrieves or sets whether the selected text will be highlighted even if the control doesn't
		/// have the focus. If set to \c True, selected text is drawn as selected if the control does not
		/// have the focus; otherwise it's drawn as normal text.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Text
		[propget, id(DISPID_TXTBOX_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the control doesn't have the focus.")]
		HRESULT AlwaysShowSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the control doesn't have the focus.")]
		HRESULT AlwaysShowSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration except \c aDefault is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_TXTBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_TXTBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's automatic scrolling features</em>
		///
		/// Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches
		/// the borders of the control's client area. Any combination of the values defined by the
		/// \c AutoScrollingConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ScrollBars, MultiLine, _ITextBoxEvents::TruncatedText, AutoScrollingConstants
		[propget, id(DISPID_TXTBOX_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoScrolling([out, retval] AutoScrollingConstants* pValue);
		[propput, id(DISPID_TXTBOX_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoScrolling([in] AutoScrollingConstants newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa ForeColor, DisabledBackColor
		[propget, id(DISPID_TXTBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TXTBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_TXTBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_TXTBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether the control cancels the IME composition string when it receives the
		/// focus. If set to \c True, the composition string is canceled; otherwise not.
		///
		/// \sa IMEMode, CompleteIMECompositionOnKillFocus
		[propget, id(DISPID_TXTBOX_CANCELIMECOMPOSITIONONSETFOCUS), helpstring("Retrieves or sets whether the control cancels the IME composition string when it receives the focus.")]
		HRESULT CancelIMECompositionOnSetFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_CANCELIMECOMPOSITIONONSETFOCUS), helpstring("Retrieves or sets whether the control cancels the IME composition string when it receives the focus.")]
		HRESULT CancelIMECompositionOnSetFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's automatic character conversion features</em>
		///
		/// Retrieves or sets the kind of conversion that is applied to characters that are typed into the
		/// control. Any of the values defined by the \c CharacterConversionConstants enumeration is valid.
		///
		/// \sa DoOEMConversion, Text, CharacterConversionConstants
		[propget, id(DISPID_TXTBOX_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control.")]
		HRESULT CharacterConversion([out, retval] CharacterConversionConstants* pValue);
		[propput, id(DISPID_TXTBOX_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control.")]
		HRESULT CharacterConversion([in] CharacterConversionConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether the control completes the IME composition string when it loses the
		/// focus. If set to \c True, the composition string is completed; otherwise not.
		///
		/// \sa IMEMode, CancelIMECompositionOnSetFocus
		[propget, id(DISPID_TXTBOX_COMPLETEIMECOMPOSITIONONKILLFOCUS), helpstring("Retrieves or sets whether the control completes the IME composition string when it loses the focus.")]
		HRESULT CompleteIMECompositionOnKillFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_COMPLETEIMECOMPOSITIONONKILLFOCUS), helpstring("Retrieves or sets whether the control completes the IME composition string when it loses the focus.")]
		HRESULT CompleteIMECompositionOnKillFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's textual cue</em>
		///
		/// Retrieves or sets the control's textual cue.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text, DisplayCueBannerOnFocus
		[propget, id(DISPID_TXTBOX_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([out, retval] BSTR* pValue);
		[propput, id(DISPID_TXTBOX_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([in] BSTR newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the color used as the control's background color, if the control is read-only or
		/// disabled. If set to -1, the system's default color is used.
		///
		/// \sa Enabled, ReadOnly, DisabledForeColor, BackColor
		[propget, id(DISPID_TXTBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is read-only or disabled.")]
		HRESULT DisabledBackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TXTBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is read-only or disabled.")]
		HRESULT DisabledBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_TXTBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_TXTBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the color used as the control's text color, if the control is read-only. If set
		/// to -1, the system's default color is used.
		///
		/// \remarks On current versions of Windows this property has no effect if the control is disabled.
		///
		/// \sa Enabled, ReadOnly, DisabledBackColor, ForeColor
		[propget, id(DISPID_TXTBOX_DISABLEDFORECOLOR), helpstring("Retrieves or sets the color used as the control's text color, if the control is read-only. On current versions of Windows this property has no effect if the control is disabled.")]
		HRESULT DisabledForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TXTBOX_DISABLEDFORECOLOR), helpstring("Retrieves or sets the color used as the control's text color, if the control is read-only. On current versions of Windows this property has no effect if the control is disabled.")]
		HRESULT DisabledForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls when the control's textual cue is displayed</em>
		///
		/// Retrieves or sets whether the control's textual cue is displayed if the control has the keyboard
		/// focus. If set to \c True, the textual cue is displayed if the control has the keyboard focus;
		/// otherwise not.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa CueBanner
		[propget, id(DISPID_TXTBOX_DISPLAYCUEBANNERONFOCUS), helpstring("Retrieves or sets whether the control's textual cue is displayed if the control has the keyboard focus. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT DisplayCueBannerOnFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_DISPLAYCUEBANNERONFOCUS), helpstring("Retrieves or sets whether the control's textual cue is displayed if the control has the keyboard focus. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT DisplayCueBannerOnFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_TXTBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control tries to work-around character set problems related to filenames</em>
		///
		/// Retrieves or sets whether the control's text is converted from the Windows character set to the OEM
		/// character set and then back to the Windows character set. Such a conversion ensures proper
		/// character conversion when the application calls the \c CharToOem function to convert a Windows
		/// string in the control to OEM characters. This property is most useful if the control contains file
		/// names that will be used on file systems that do not support Unicode.\n
		/// If set to \c True, the conversion is performed; otherwise not.
		///
		/// \sa CharacterConversion, Text,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647473.aspx">CharToOem</a>
		[propget, id(DISPID_TXTBOX_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set.")]
		HRESULT DoOEMConversion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set.")]
		HRESULT DoOEMConversion([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa AllowDragDrop, RegisterForOLEDragDrop, _ITextBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_TXTBOX_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_TXTBOX_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([in] LONG newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		///
		/// \sa ReadOnly
		[propget, id(DISPID_TXTBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's first visible character</em>
		///
		/// Retrieves the zero-based index of the first visible character in a single-line control.
		///
		/// \remarks This property is read-only.
		///
		/// \sa FirstVisibleLine, GetLineFromChar, MultiLine
		[propget, id(DISPID_TXTBOX_FIRSTVISIBLECHAR), helpstring("Retrieves the zero-based index of the first visible character in a single-line control. This property is read-only."), nonbrowsable]
		HRESULT FirstVisibleChar([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the control's first visible line</em>
		///
		/// Retrieves the zero-based index of the uppermost visible line in a multiline control.
		///
		/// \remarks This property is read-only.
		///
		/// \sa LastVisibleLine, FirstVisibleChar, MultiLine, GetLineCount
		[propget, id(DISPID_TXTBOX_FIRSTVISIBLELINE), helpstring("Retrieves the zero-based index of the uppermost visible line in a multiline control. This property is read-only."), nonbrowsable]
		HRESULT FirstVisibleLine([out, retval] LONG* pValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, ForeColor, Text
		[propget, id(DISPID_TXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_TXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_TXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor, DisabledForeColor
		[propget, id(DISPID_TXTBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TXTBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the height of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the height (in pixels) of the control's formatting rectangle.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleLeft, FormattingRectangleTop, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_TXTBOX_FORMATTINGRECTANGLEHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_FORMATTINGRECTANGLEHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the x-coordinate of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the distance (in pixels) between the left borders of the control's formatting
		/// rectangle and its client area.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleTop, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_TXTBOX_FORMATTINGRECTANGLELEFT), helpstring("Retrieves or sets the distance (in pixels) between the left borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleLeft([out, retval] OLE_XPOS_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_FORMATTINGRECTANGLELEFT), helpstring("Retrieves or sets the distance (in pixels) between the left borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleLeft([in] OLE_XPOS_PIXELS newValue);
		/// \brief <em>Specifies the y-coordinate of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting
		/// rectangle and its client area.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_TXTBOX_FORMATTINGRECTANGLETOP), helpstring("Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleTop([out, retval] OLE_YPOS_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_FORMATTINGRECTANGLETOP), helpstring("Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleTop([in] OLE_YPOS_PIXELS newValue);
		/// \brief <em>Specifies the width of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's formatting rectangle.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleTop,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_TXTBOX_FORMATTINGRECTANGLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_FORMATTINGRECTANGLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the horizontal alignment of the control's content</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's content. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \attention On Windows XP, changing this property destroys and recreates the control window.
		///
		/// \sa Text, HAlignmentConstants
		[propget, id(DISPID_TXTBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_TXTBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Retrieves the imagelist containing the drag image</em>
		///
		/// Retrieves the handle to the imagelist containing the drag image that is used during a
		/// drag'n'drop operation to visualize the dragged data.
		///
		/// \sa ShowDragImage, BeginDrag, _ITextBoxEvents::DragMouseMove
		[propget, id(DISPID_TXTBOX_HDRAGIMAGELIST), helpstring("Retrieves the handle to the imagelist containing the drag image that is used during a drag'n'drop operation to visualize the dragged data."), nonbrowsable]
		HRESULT hDragImageList([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _ITextBoxEvents::MouseHover
		[propget, id(DISPID_TXTBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_TXTBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _ITextBoxEvents::RecreatedControlWindow, _ITextBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_TXTBOX_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa CancelIMECompositionOnSetFocus, CompleteIMECompositionOnKillFocus, IMEModeConstants
		[propget, id(DISPID_TXTBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_TXTBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \sa SetInsertMarkPosition
		[propget, id(DISPID_TXTBOX_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TXTBOX_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the control's behavior at line ends</em>
		///
		/// Retrieves or sets whether the control inserts soft line-break characters at the end of lines that
		/// are broken because of wordwrapping. A soft line break consists of two carriage returns and a line
		/// feed. If set to \c True, soft line breaks are inserted; otherwise not.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa Text, MultiLine
		[propget, id(DISPID_TXTBOX_INSERTSOFTLINEBREAKS), helpstring("Retrieves or sets whether the control inserts soft line-break characters at the end of lines that are broken because of wordwrapping. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT InsertSoftLineBreaks([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_INSERTSOFTLINEBREAKS), helpstring("Retrieves or sets whether the control inserts soft line-break characters at the end of lines that are broken because of wordwrapping. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT InsertSoftLineBreaks([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the control's last visible line</em>
		///
		/// Retrieves the zero-based index of the last visible line in a multiline control.
		///
		/// \remarks This property is read-only.
		///
		/// \sa FirstVisibleLine, MultiLine, GetLineCount
		[propget, id(DISPID_TXTBOX_LASTVISIBLELINE), helpstring("Retrieves the zero-based index of the last visible line in a multiline control. This property is read-only."), nonbrowsable]
		HRESULT LastVisibleLine([out, retval] LONG* pValue);
		/// \brief <em>Specifies the width of the whitespace to the left of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's left margin. If set to -1, a value, that
		/// depends on the control's font, is used.
		///
		/// \sa RightMargin, Font
		[propget, id(DISPID_TXTBOX_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's left margin.")]
		HRESULT LeftMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's left margin.")]
		HRESULT LeftMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the text lines' height</em>
		///
		/// Retrieves the height of each text line.
		///
		/// \remarks This property is read-only.
		///
		/// \sa FirstVisibleLine, LastVisibleLine
		[propget, id(DISPID_TXTBOX_LINEHEIGHT), helpstring("Retrieves the height of each text line. This property is read-only."), nonbrowsable]
		HRESULT LineHeight([out, retval] LONG* pValue);
		/// \brief <em>Specifies the maximum length of the input</em>
		///
		/// Retrieves or sets the maximum number of characters, that the user can type into the control. If set
		/// to -1, the system's default setting is used.
		///
		/// \remarks Text, that is set through the \c Text property may exceed this limit.
		///
		/// \sa TextLength, Text, _ITextBoxEvents::TruncatedText
		[propget, id(DISPID_TXTBOX_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([out, retval] LONG* pValue);
		[propput, id(DISPID_TXTBOX_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([in] LONG newValue);
		/// \brief <em>Retrieves or sets a flag indicating whether the control's content has changed</em>
		///
		/// Retrieves or sets a flag indicating whether the control's content has changed. A value of \c True
		/// stands for changed content, a value of \c False for unchanged content.
		///
		/// \sa Text, _ITextBoxEvents::ContentChanged
		[propget, id(DISPID_TXTBOX_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the control's content has changed.")]
		HRESULT Modified([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the control's content has changed.")]
		HRESULT Modified([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, SelectedTextMouseIcon, MousePointerConstants
		[propget, id(DISPID_TXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_TXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_TXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, SelectedTextMousePointer, MousePointerConstants
		[propget, id(DISPID_TXTBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_TXTBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the control displays text in multiple lines</em>
		///
		/// Retrieves or sets whether the control processes carriage returns and displays the content in
		/// multiple lines. If set to \c True, the content is displayed on multiple lines; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Text, ScrollBars, GetLineCount, FirstVisibleLine, LastVisibleLine, HAlignment
		[propget, id(DISPID_TXTBOX_MULTILINE), helpstring("Retrieves or sets whether the control processes carriage returns and displays the content on multiple lines. Changing this property destroys and recreates the control window.")]
		HRESULT MultiLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_MULTILINE), helpstring("Retrieves or sets whether the control processes carriage returns and displays the content on multiple lines. Changing this property destroys and recreates the control window.")]
		HRESULT MultiLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_TXTBOX_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_TXTBOX_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies the replacement character for password input fields</em>
		///
		/// Retrieves or sets the code of the character, that is displayed instead of the real characters, if
		/// the \c UsePasswordChar property is set to \c True. If set to 0, the system's default setting is
		/// used.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c True.
		///
		/// \sa UsePasswordChar, Text, MultiLine
		[propget, id(DISPID_TXTBOX_PASSWORDCHAR), helpstring("Retrieves or sets the code of the character, that is displayed instead of the real characters, if the 'UsePasswordChar' property is set to 'True'. This property is ignored, if the 'MultiLine' property is set to 'True'.")]
		HRESULT PasswordChar([out, retval] SHORT* pValue);
		[propput, id(DISPID_TXTBOX_PASSWORDCHAR), helpstring("Retrieves or sets the code of the character, that is displayed instead of the real characters, if the 'UsePasswordChar' property is set to 'True'. This property is ignored, if the 'MultiLine' property is set to 'True'.")]
		HRESULT PasswordChar([in] SHORT newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _ITextBoxEvents::ContextMenu
		[propget, id(DISPID_TXTBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_TXTBOX_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the user can edit the displayed text</em>
		///
		/// Retrieves or sets whether the control accepts user input, that would change the control's content.
		/// If set to \c False, such user input is accepted; otherwise not.
		///
		/// \sa Enabled, Text
		[propget, id(DISPID_TXTBOX_READONLY), helpstring("Retrieves or sets whether the control accepts user input, that would change the control's content.")]
		HRESULT ReadOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_READONLY), helpstring("Retrieves or sets whether the control accepts user input, that would change the control's content.")]
		HRESULT ReadOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa AllowDragDrop, SupportOLEDragImages, _ITextBoxEvents::OLEDragEnter
		[propget, id(DISPID_TXTBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the width of the whitespace to the right of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's right margin. If set to -1, a value, that
		/// depends on the control's font, is used.
		///
		/// \sa LeftMargin, Font
		[propget, id(DISPID_TXTBOX_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's right margin.")]
		HRESULT RightMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's right margin.")]
		HRESULT RightMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention On Windows XP, changing this property destroys and recreates the control window.
		///
		/// \sa IMEMode, _ITextBoxEvents::WritingDirectionChanged, RightToLeftConstants
		[propget, id(DISPID_TXTBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_TXTBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the scrollbars to show</em>
		///
		/// Retrieves or sets the scrollbars to show. Any combination of the values defined by the
		/// \c ScrollBarsConstants enumeration is valid.
		///
		/// \sa AutoScrolling, MultiLine, Scroll, _ITextBoxEvents::Scrolling, ScrollBarsConstants
		[propget, id(DISPID_TXTBOX_SCROLLBARS), helpstring("Retrieves or sets the scrollbars to show.")]
		HRESULT ScrollBars([out, retval] ScrollBarsConstants* pValue);
		[propput, id(DISPID_TXTBOX_SCROLLBARS), helpstring("Retrieves or sets the scrollbars to show.")]
		HRESULT ScrollBars([in] ScrollBarsConstants newValue);
		/// \brief <em>Retrieves the currently selected text</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetSelection, SetSelection, ReplaceSelectedText, Text
		[propget, id(DISPID_TXTBOX_SELECTEDTEXT), helpstring("Retrieves the currently selected text. This property is read-only."), nonbrowsable]
		HRESULT SelectedText([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c SelectedTextMousePointer is set to
		/// \c mpCustom and the mouse cursor is located over selected text.
		///
		/// \sa SelectedTextMousePointer, MouseIcon, MousePointerConstants
		[propget, id(DISPID_TXTBOX_SELECTEDTEXTMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used if the mouse cursor is placed over selected text.")]
		HRESULT SelectedTextMouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_TXTBOX_SELECTEDTEXTMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used if the mouse cursor is placed over selected text.")]
		HRESULT SelectedTextMouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_TXTBOX_SELECTEDTEXTMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used if the mouse cursor is placed over selected text.")]
		HRESULT SelectedTextMouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area over selected text. Any of the values defined by the \c MousePointerConstants
		/// enumeration is valid.
		///
		/// \sa SelectedTextMouseIcon, MousePointer, MousePointerConstants
		[propget, id(DISPID_TXTBOX_SELECTEDTEXTMOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area over selected text.")]
		HRESULT SelectedTextMousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_TXTBOX_SELECTEDTEXTMOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area over selected text.")]
		HRESULT SelectedTextMousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa hDragImageList, SupportOLEDragImages, _ITextBoxEvents::DragMouseMove
		[propget, id(DISPID_TXTBOX_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, ShowDragImage, OLEDragImageStyle, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_TXTBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's tab stops</em>
		///
		/// Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a
		/// \c Variant containing an array of integer values, each specifying a tab stop's position.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa AcceptTabKey, TabWidth
		[propget, id(DISPID_TXTBOX_TABSTOPS), helpstring("Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a 'Variant' containing an array of integer values, each specifying a tab stop's position. This property is ignored, if the 'MultiLine' property is set to 'False'."), nonbrowsable]
		HRESULT TabStops([out, retval] VARIANT* pValue);
		[propput, id(DISPID_TXTBOX_TABSTOPS), helpstring("Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a 'Variant' containing an array of integer values, each specifying a tab stop's position. This property is ignored, if the 'MultiLine' property is set to 'False'."), nonbrowsable]
		HRESULT TabStops([in] VARIANT newValue);
		/// \brief <em>Specifies the width of a tab</em>
		///
		/// Retrieves or sets the distance (in pixels) between 2 tab stops. If set to -1, the system's default
		/// value is used.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.\n
		///          This property is ignored, if the \c TabStops property is not set to \c Empty.
		///
		/// \sa AcceptTabKey, TabStops
		[propget, id(DISPID_TXTBOX_TABWIDTH), helpstring("Retrieves or sets the distance (in pixels) between 2 tab stops. This property is ignored, if the 'MultiLine' property is set to 'False' or the 'TabStops' property is set to 'Empty'.")]
		HRESULT TabWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TXTBOX_TABWIDTH), helpstring("Retrieves or sets the distance (in pixels) between 2 tab stops. This property is ignored, if the 'MultiLine' property is set to 'False' or the 'TabStops' property is set to 'Empty'.")]
		HRESULT TabWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_TXTBOX_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's content</em>
		///
		/// Retrieves or sets the control's content.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa TextLength, MaxTextLength, GetLine, AcceptNumbersOnly, PasswordChar, CueBanner, HAlignment,
		///     MultiLine, ForeColor, Font, _ITextBoxEvents::TextChanged
		[propget, id(DISPID_TXTBOX_TEXT), helpstring("Retrieves or sets the control's content."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_TXTBOX_TEXT), helpstring("Retrieves or sets the control's content."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Retrieves the length of the text</em>
		///
		/// Retrieves the length of the text specified by the \c Text property.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaxTextLength, Text
		[propget, id(DISPID_TXTBOX_TEXTLENGTH), helpstring("Retrieves the length of the text specified by the 'Text' property. This property is read-only."), nonbrowsable]
		HRESULT TextLength([out, retval] LONG* pValue);
		/// \brief <em>Controls which formatting rectangle the control is using</em>
		///
		/// Retrieves or sets whether the control uses the formatting rectangle defined by the
		/// \c FormattingRectangle* properties.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When an edit control is first displayed, the
		/// two rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).\n
		/// If this property is set to \c False, the formatting rectangle is set to its default values.
		/// Otherwise it's defined by the \c FormattingRectangle* properties.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleTop,
		///     FormattingRectangleWidth, MultiLine
		[propget, id(DISPID_TXTBOX_USECUSTOMFORMATTINGRECTANGLE), helpstring("Retrieves or sets whether the control uses the formatting rectangle defined by the 'FormattingRectangle*' properties. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT UseCustomFormattingRectangle([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_USECUSTOMFORMATTINGRECTANGLE), helpstring("Retrieves or sets whether the control uses the formatting rectangle defined by the 'FormattingRectangle*' properties. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT UseCustomFormattingRectangle([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control's content is automatically replaced to hide it</em>
		///
		/// Retrieves or sets whether the control hides user input by (visually) replacing each character with
		/// the character specified by the \c PasswordChar property. If set to \c True, user input is
		/// (visually) replaced; otherwise not.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c True.
		///
		/// \sa PasswordChar, Text, MultiLine
		[propget, id(DISPID_TXTBOX_USEPASSWORDCHAR), helpstring("Retrieves or sets whether the control hides user input by (visually) replacing each character with the character specified by the 'PasswordChar' property. This property is ignored, if the 'MultiLine' property is set to 'True'.")]
		HRESULT UsePasswordChar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_USEPASSWORDCHAR), helpstring("Retrieves or sets whether the control hides user input by (visually) replacing each character with the character specified by the 'PasswordChar' property. This property is ignored, if the 'MultiLine' property is set to 'True'.")]
		HRESULT UsePasswordChar([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_TXTBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TXTBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_TXTBOX_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Controls word processing</em>
		///
		/// Retrieves or sets the function that is responsible to tell the control where a word starts and
		/// where it ends. This property takes the address of a function having the following signature:\n
		/// \code
		///   FindWorkBreak(ByVal pText As Long, ByVal startPosition As Long, ByVal textLength As Long, ByVal flags As Long) As Long
		/// \endcode
		/// The \c pText argument is a pointer to the control's text. In ANSI builds of the control, this text
		/// is encoded in ANSI; otherwise it's encoded in Unicode.\n
		/// The \c startPosition argument specifies the (zero-based) position within the text, at which the
		/// function should begin checking for a word break.\n
		/// The \c textLength argument specifies the length of the text pointed to by \c pText in characters.\n
		/// The \c flags argument specifies the action to be taken by the function. This can be one of the
		/// following values:
		/// - \c WB_ISDELIMITER Check whether the character at the specified position is a delimiter.
		/// - \c WB_LEFT Find the beginning of a word to the left of the specified position.
		/// - \c WB_RIGHT Find the beginning of a word to the right of the specified position. This is useful
		///   in right-aligned edit controls.
		///
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is a delimiter, the function must return a non-zero value.\n
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is not a delimiter, the function must return zero.\n
		/// If the \c flags parameter specifies \c WB_LEFT or \c WB_RIGHT, the function must return the
		/// (zero-based) index to the beginning of a word in the specified text.\n\n
		/// If this property is set to 0, the system's internal function is used.
		///
		/// \sa Text, HAlignment,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms672125.aspx">EditWordBreakProc</a>
		[propget, id(DISPID_TXTBOX_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([out, retval] LONG* pValue);
		[propput, id(DISPID_TXTBOX_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([in] LONG newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_TXTBOX_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Appends the specified text to the end of the current text</em>
		///
		/// \param[in] text The text to append.
		/// \param[in] setCaretToEnd If \c True, the caret is automatically moved to the end of the text;
		///            otherwise not.
		/// \param[in] scrollToCaret If \c True, the control is automatically scrolled to the caret; otherwise
		///            not.
		///
		/// \sa Text
		[id(DISPID_TXTBOX_APPENDTEXT), helpstring("Appends the specified text to the end of the current text.")]
		HRESULT AppendText([in] BSTR Text, [in, defaultvalue(0)] VARIANT_BOOL setCaretToEnd, [in, defaultvalue(-1)] VARIANT_BOOL scrollToCaret);
		/// \brief <em>Enters drag'n'drop mode</em>
		///
		/// \param[in] draggedTextFirstChar The zero-based index of the first character of the text to drag.
		/// \param[in] draggedTextLastChar The zero-based index of the last character of the text to drag.
		/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
		///            visualize the drag'n'drop operation. If \c 0, no drag image is used.
		//            visualize the drag'n'drop operation. If -1, the control creates the drag image
		//            itself; if \c 0, no drag image is used.
		/// \param[in,out] xHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		/// \param[in,out] yHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		///
		/// \sa OLEDrag, GetDraggedTextRange, EndDrag, hDragImageList, _ITextBoxEvents::BeginDrag,
		///     _ITextBoxEvents::BeginRDrag
		//     _ITextBoxEvents::BeginRDrag, CreateDragImage
		[id(DISPID_TXTBOX_BEGINDRAG), helpstring("Enters drag'n'drop mode.")]
		HRESULT BeginDrag([in] LONG draggedTextFirstChar, [in] LONG draggedTextLastChar, [in, defaultvalue(0)] OLE_HANDLE hDragImageList, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xHotSpot, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yHotSpot);
		/// \brief <em>Determines whether there are any actions in the control's undo queue</em>
		///
		/// \return \c True if there are actions in the undo queue; otherwise \c False.
		///
		/// \sa Undo, EmptyUndoBuffer
		[id(DISPID_TXTBOX_CANUNDO), helpstring("Determines whether there are any actions in the control's undo queue.")]
		HRESULT CanUndo([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the specified character's position in client coordinates</em>
		///
		/// Retrieves the position (in pixels) of the specified character within the control's client area.
		///
		/// \param[in] characterIndex The zero-based index of the character within the control, for which to
		///            retrieve the position. If the character is a line delimiter, the returned coordinates
		///            indicate a point just beyond the last visible character in the line. If the specified
		///            index is greater than the index of the last character in the control, the function
		///            fails.
		/// \param[out] x The x-coordinate (in pixels) of the character relative to the control's upper-left
		///             corner.
		/// \param[out] y The y-coordinate (in pixels) of the character relative to the control's upper-left
		///             corner.
		///
		/// \sa PositionToCharIndex
		[id(DISPID_TXTBOX_CHARINDEXTOPOSITION), helpstring("Retrieves the position (in pixels) of the specified character within the control's client area.")]
		HRESULT CharIndexToPosition([in] LONG characterIndex, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* x, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* y);
		/// \brief <em>Clears the control's undo queue</em>
		///
		/// \sa CanUndo, Undo
		[id(DISPID_TXTBOX_EMPTYUNDOBUFFER), helpstring("Clears the control's undo queue.")]
		HRESULT EmptyUndoBuffer(void);
		/// \brief <em>Exits drag'n'drop mode</em>
		///
		/// \param[in] abort If \c True, the drag'n'drop operation will be handled as aborted; otherwise
		///            it will be handled as a drop.
		///
		/// \sa GetDraggedTextRange, BeginDrag, _ITextBoxEvents::AbortedDrag, _ITextBoxEvents::Drop
		[id(DISPID_TXTBOX_ENDDRAG), helpstring("Exits drag'n'drop mode.")]
		HRESULT EndDrag([in] VARIANT_BOOL abort);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified character. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] characterIndex The zero-based index of the character at which the insertion mark should
		///             be displayed.
		///
		/// \sa SetInsertMarkPosition, GetInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TXTBOX_GETCLOSESTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] LONG* characterIndex);
		/// \brief <em>Retrieves the dragged text's start and end</em>
		///
		/// Retrieves the zero-based character indices of the dragged text's start and end.
		///
		/// \param[out] draggedTextFirstChar The zero-based index of the character at which the dragged text
		///             starts.
		/// \param[out] draggedTextLastChar The zero-based index of the last character of the dragged text.
		///
		/// \sa BeginDrag, OLEDrag
		[id(DISPID_TXTBOX_GETDRAGGEDTEXTRANGE), helpstring("Retrieves the zero-based character indices of the dragged text's start and end.")]
		HRESULT GetDraggedTextRange([in, out, defaultvalue(0)] LONG* draggedTextFirstChar, [in, out, defaultvalue(0)] LONG* draggedTextLastChar);
		/// \brief <em>Retrieves the zero-based index of the first character of the specified line</em>
		///
		/// \param[in] lineIndex The zero-based index of the line to retrieve the first character for. If set
		///            to -1, the index of the line containing the caret is used.
		///
		/// \return The zero-based index of the first character of the line. -1 if the specified line index is
		///         greater than the total number of lines.
		///
		/// \sa GetLineFromChar, MultiLine
		[id(DISPID_TXTBOX_GETFIRSTCHAROFLINE), helpstring("Retrieves the zero-based index of the first character of the specified line.")]
		HRESULT GetFirstCharOfLine([in] LONG lineIndex, [out, retval] LONG* pValue);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified character. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] characterIndex The zero-based index of the character at which the insertion mark is
		///             displayed.
		///
		/// \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TXTBOX_GETINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] LONG* characterIndex);
		/// \brief <em>Retrieves the text of the specified line</em>
		///
		/// \param[in] lineIndex The zero-based index of the line to retrieve the text for.
		///
		/// \return The line's text.
		///
		/// \sa GetLineLength, MultiLine, Text
		[id(DISPID_TXTBOX_GETLINE), helpstring("Retrieves the text of the specified line.")]
		HRESULT GetLine([in] LONG lineIndex, [out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the number of lines in the control</em>
		///
		/// \return The number of lines.
		///
		/// \sa FirstVisibleLine, LastVisibleLine, MultiLine
		[id(DISPID_TXTBOX_GETLINECOUNT), helpstring("Retrieves the number of lines in the control.")]
		HRESULT GetLineCount([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the zero-based index of the line that contains the specified character</em>
		///
		/// \param[in] characterIndex The zero-based index of the character within the control. If set to
		///            -1, the index of the character at which the selection begins, is used. If there's no
		///            selection, the index of the character next to the caret is used.
		///
		/// \return The zero-based index of the line containing the character.
		///
		/// \sa FirstVisibleChar, GetFirstCharOfLine, MultiLine, GetSelection
		[id(DISPID_TXTBOX_GETLINEFROMCHAR), helpstring("Retrieves the zero-based index of the line that contains the specified character.")]
		HRESULT GetLineFromChar([in] LONG characterIndex, [out, retval] LONG* pValue);
		/// \brief <em>Retrieves the number of characters in the specified line</em>
		///
		/// \param[in] lineIndex The zero-based index of the line to retrieve the length for. If set to -1, the
		///            number of unselected characters on lines containing selected characters is retrieved.
		///            E. g. if the selection extended from the fourth character of one line through the eighth
		///            character from the end of the next line, the return value would be 10 (three characters
		///            on the first line and seven on the next).
		///
		/// \return The number of characters in the line.
		///
		/// \sa GetLine, MultiLine
		[id(DISPID_TXTBOX_GETLINELENGTH), helpstring("Retrieves the number of characters in the specified line.")]
		HRESULT GetLineLength([in] LONG lineIndex, [out, retval] LONG* pValue);
		/// \brief <em>Retrieves the current selection's start and end</em>
		///
		/// Retrieves the zero-based character indices of the current selection's start and end.
		///
		/// \param[out] selectionStart The zero-based index of the character at which the selection starts.
		/// \param[out] selectionEnd The zero-based index of the first unselected character after the end of
		///             the selection.
		///
		/// \sa SetSelection, ReplaceSelectedText, SelectedText
		[id(DISPID_TXTBOX_GETSELECTION), helpstring("Retrieves the zero-based character indices of the current selection's start and end.")]
		HRESULT GetSelection([in, out, defaultvalue(0)] LONG* selectionStart, [in, out, defaultvalue(0)] LONG* selectionEnd);
		/// \brief <em>Hides any balloon tips associated with the control</em>
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa ShowBalloonTip
		[id(DISPID_TXTBOX_HIDEBALLOONTIP), helpstring("Hides any balloon tips associated with the control. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT HideBalloonTip([out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Determines whether the specified line's text is entirely visible or truncated</em>
		///
		/// \param[in] lineIndex The zero-based index of the line to check.
		///
		/// \return \c True if not all of the specified line's text is visible; otherwise \c False.
		///
		/// \sa GetLine
		[id(DISPID_TXTBOX_ISTEXTTRUNCATED), helpstring("Determines whether the specified line's text is entirely visible or truncated.")]
		HRESULT IsTextTruncated([in, defaultvalue(0)] LONG lineIndex, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_TXTBOX_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedTextFirstChar The zero-based index of the first character of the text to drag.
		///            This parameter is used to generate the drag image, if \c hWndToAskForDragImage is set to
		///            -1.
		/// \param[in] draggedTextLastChar The zero-based index of the last character of the text to drag. This
		///            parameter is used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to any value larger than 1,
		///            this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa BeginDrag, _ITextBoxEvents::BeginDrag, _ITextBoxEvents::BeginRDrag,
		///     _ITextBoxEvents::OLEStartDrag, _ITextBoxEvents::OLEGiveFeedback,
		///     _ITextBoxEvents::OLEQueryContinueDrag,
		///     SupportOLEDragImages, OLEDragImageStyle, OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_TXTBOX_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(-1)] LONG draggedTextFirstChar, [in, defaultvalue(-1)] LONG draggedTextLastChar, [in, defaultvalue(0)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Retrieves the character closest to the specified position</em>
		///
		/// Retrieves the zero-based index of the character nearest the specified position.
		///
		/// \param[in] x The x-coordinate (in pixels) of the position to retrieve the nearest character for. It
		///            is relative to the control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the position to retrieve the nearest character for. It
		///            is relative to the control's upper-left corner.
		/// \param[out] characterIndex The zero-based index of the character within the control, that is
		///             nearest to the specified position. If the specified point is beyond the last character
		///             in the control, this value indicates the last character in the control. The index
		///             indicates the line delimiter if the specified point is beyond the last visible
		///             character in a line.
		/// \param[out] lineIndex The zero-based index of the line, that contains the character specified by
		///             the \c characterIndex parameter.
		///
		/// \remarks If a point outside the bounds of the control is passed, the function fails.
		///
		/// \sa CharIndexToPosition
		[id(DISPID_TXTBOX_POSITIONTOCHARINDEX), helpstring("Retrieves the zero-based index of the character nearest the specified position.")]
		HRESULT PositionToCharIndex([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out, defaultvalue(0)] LONG* characterIndex, [in, out, defaultvalue(0)] LONG* lineIndex);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_TXTBOX_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Replaces the currently selected text</em>
		///
		/// Replaces the control's currently selected text.
		///
		/// \param[in] replacementText The text that replaces the currently selected text.
		/// \param[in] undoable If \c True, this action is inserted into the control's undo queue; otherwise
		///            not.
		///
		/// \sa GetSelection, SetSelection, SelectedText
		[id(DISPID_TXTBOX_REPLACESELECTEDTEXT), helpstring("Replaces the control's currently selected text.")]
		HRESULT ReplaceSelectedText([in] BSTR replacementText, [in, defaultvalue(0)] VARIANT_BOOL undoable);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_TXTBOX_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Scrolls the control</em>
		///
		/// \param[in] axis The axis which is to be scrolled. Any combination of the values defined by the
		///            \c ScrollAxisConstants enumeration is valid.
		/// \param[in] directionAndIntensity The intensity and direction of the action. Any of the values
		///            defined by the \c ScrollDirectionConstants enumeration is valid.
		/// \param[in] linesToScrollVertically The number of lines to scroll vertically. This parameter is
		///            ignored, if \c directionAndIntensity is not set to \c sdCustom.
		/// \param[in] charactersToScrollHorizontally The number of characters to scroll horizontally. This
		///            parameter is ignored, if \c directionAndIntensity is not set to \c sdCustom.
		///
		/// \remarks This method has no effect if the \c MultiLine property is set to \c False.
		///
		/// \sa ScrollCaretIntoView, ScrollBars, AutoScrolling, MultiLine, _ITextBoxEvents::Scrolling,
		///     ScrollAxisConstants, ScrollDirectionConstants
		[id(DISPID_TXTBOX_SCROLL), helpstring("Scrolls the control. This method has no effect if the 'MultiLine' property is set to 'False'.")]
		HRESULT Scroll([in] ScrollAxisConstants axis, [in] ScrollDirectionConstants directionAndIntensity, [in, defaultvalue(0)] LONG linesToScrollVertically, [in, defaultvalue(0)] LONG charactersToScrollHorizontally);
		/// \brief <em>Scrolls the control so that the caret is visible</em>
		///
		/// Ensures that the control's caret is visible by scrolling the control if necessary.
		///
		/// \sa Scroll, ScrollBars, AutoScrolling, MultiLine, _ITextBoxEvents::Scrolling
		[id(DISPID_TXTBOX_SCROLLCARETINTOVIEW), helpstring("Ensures that the control's caret is visible by scrolling the control if necessary.")]
		HRESULT ScrollCaretIntoView(void);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified character. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] characterIndex The zero-based index of the character at which to display the insertion
		///            mark. If set to -1, the insertion mark is removed.
		///
		/// \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkColor, AllowDragDrop,
		///     RegisterForOLEDragDrop, InsertMarkPositionConstants
		[id(DISPID_TXTBOX_SETINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] LONG characterIndex);
		/// \brief <em>Sets the selection's start and end</em>
		///
		/// Sets the zero-based character indices of the selection's start and end.
		///
		/// \param[in] selectionStart The zero-based index of the character at which the selection starts. If
		///            set to -1, the current selection is cleared.
		/// \param[in] selectionEnd The zero-based index of the first unselected character after the end of
		///            the selection.
		///
		/// \remarks To select all text in the control, set \c selectionStart to 0 and \c selectionEnd to -1.
		///
		/// \sa GetSelection, ReplaceSelectedText, SelectedText
		[id(DISPID_TXTBOX_SETSELECTION), helpstring("Sets the zero-based character indices of the selection's start and end.")]
		HRESULT SetSelection([in] LONG selectionStart, [in] LONG selectionEnd);
		/// \brief <em>Displays a balloon tip associated with the control</em>
		///
		/// \param[in] title The title of the balloon tip to display.
		/// \param[in] text The balloon tip text to display.
		/// \param[in] icon The icon of the balloon tip to display. Any of the values defined by the
		///            \c BalloonTipIconConstants enumeration is valid.
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa HideBalloonTip, BalloonTipIconConstants
		[id(DISPID_TXTBOX_SHOWBALLOONTIP), helpstring("Displays a balloon tip associated with the control. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT ShowBalloonTip([in] BSTR title, [in] BSTR text, [in, defaultvalue(btiNone)] BalloonTipIconConstants icon, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Undoes the last action in the control's undo queue</em>
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \sa CanUndo, EmptyUndoBuffer
		[id(DISPID_TXTBOX_UNDO), helpstring("Undoes the last action in the control's undo queue.")]
		HRESULT Undo([out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _ITextBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_TXTBOX_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _ITextBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c TextBox class' events interface</em>
	///
	/// This interface defines all events the \c TextBox class may raise.
	///
	/// \sa ITextBox
	[
		uuid(37D6124D-C498-44d8-88F2-6DFB2EB0A321),
		helpstring("ITextBox-event-interface")
	]
	dispinterface _ITextBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The control's text was changed</em>
			///
			/// Will be fired after the control's content was changed.
			///
			/// \remarks This is the control's default event.\n
			///          This event may be disabled.
			///
			/// \sa ITextBox::Text
			[id(DISPID_TXTBOXE_TEXTCHANGED), helpstring("Will be fired after the control's content was changed. This event may be disabled.")]
			void TextChanged(void);
			/// \brief <em>A drag'n'drop operation was aborted</em>
			///
			/// Will be fired if a drag'n'drop operation was aborted.
			///
			/// \sa Drop, ITextBox::EndDrag
			[id(DISPID_TXTBOXE_ABORTEDDRAG), helpstring("Will be fired if a drag'n'drop operation was aborted.")]
			void AbortedDrag(void);
			/// \brief <em>The control's text is about to be drawn</em>
			///
			/// Will be fired before the control's content is drawn. This makes it possible to resize the
			/// control, if necessary.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ITextBox::Text, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_BEFOREDRAWTEXT), helpstring("Will be fired before the control's content is drawn. This event may be disabled.")]
			void BeforeDrawText(void);
			/// \brief <em>The user seems to want to drag text</em>
			///
			/// Will be fired if the user seems to want to drag text using the left mouse button.
			///
			/// \param[in] firstChar The zero-based index of the first character of the text that the user wants
			///            to drag.
			/// \param[in] lastChar The zero-based index of the last character of the text that the user wants to
			///            drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \sa ITextBox::BeginDrag, ITextBox::OLEDrag, ITextBox::AllowDragDrop, BeginRDrag
			[id(DISPID_TXTBOXE_BEGINDRAG), helpstring("Will be fired if the user seems to want to drag text using the left mouse button.")]
			void BeginDrag(LONG firstChar, LONG lastChar, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user seems to want to drag text</em>
			///
			/// Will be fired if the user seems to want to drag text using the right mouse button.
			///
			/// \param[in] firstChar The zero-based index of the first character of the text that the user wants
			///            to drag.
			/// \param[in] lastChar The zero-based index of the last character of the text that the user wants to
			///            drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \sa ITextBox::BeginDrag, ITextBox::OLEDrag, ITextBox::AllowDragDrop, BeginDrag
			[id(DISPID_TXTBOXE_BEGINRDRAG), helpstring("Will be fired if the user seems to want to drag text using the right mouse button.")]
			void BeginRDrag(LONG firstChar, LONG lastChar, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick
			[id(DISPID_TXTBOXE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, ITextBox::hWnd
			[id(DISPID_TXTBOXE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area during a
			/// drag'n'drop operation.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa MouseMove, OLEDragMouseMove, ITextBox::DragScrollTimeBase, ITextBox::SetInsertMarkPosition,
			///     ITextBox::BeginDrag
			[id(DISPID_TXTBOXE_DRAGMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area during a drag'n'drop operation.")]
			void DragMouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>A drag'n'drop operation ended successful</em>
			///
			/// Will be fired if a drag'n'drop operation ended successful.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \sa AbortedDrag, ITextBox::EndDrag
			[id(DISPID_TXTBOXE_DROP), helpstring("Will be fired if a drag'n'drop operation ended successful.")]
			void Drop(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ITextBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, ITextBox::HoverTime, ExtendedMouseButtonConstants,
			///     ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ExtendedMouseButtonConstants,
			///     ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, ScrollAxisConstants, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa ITextBox::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_TXTBOXE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ITextBox::RegisterForOLEDragDrop,
			///     ITextBox::FinishOLEDragDrop, OLEDropEffectConstants
			[id(DISPID_TXTBOXE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ITextBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, ITextBox::DragScrollTimeBase
			[id(DISPID_TXTBOXE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, ITextBox::OLEDrag
			[id(DISPID_TXTBOXE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ITextBox::RegisterForOLEDragDrop
			[id(DISPID_TXTBOXE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, ITextBox::OLEDrag
			[id(DISPID_TXTBOXE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ITextBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, ITextBox::DragScrollTimeBase
			[id(DISPID_TXTBOXE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa ITextBox::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_TXTBOXE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa ITextBox::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_TXTBOXE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TXTBOXE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TXTBOXE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa ITextBox::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_TXTBOXE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the control cannot allocate enough memory to meet a specific request.
			[id(DISPID_TXTBOXE_OUTOFMEMORY), helpstring("Will be fired if the control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, ITextBox::hWnd
			[id(DISPID_TXTBOXE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_TXTBOXE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The control is being scrolled</em>
			///
			/// Will be fired if the control is being scrolled.
			///
			/// \param[in] axis The axis which is scrolled. Any of the values defined by the
			///            \c ScrollAxisConstants enumeration is valid.
			///
			/// \remarks This event isn't raised if the \c MultiLine property is set to \c False.\n
			///          This event may be disabled.
			///
			/// \sa ITextBox::MultiLine, ITextBox::ScrollBars, ITextBox::DisabledEvents, ScrollAxisConstants
			[id(DISPID_TXTBOXE_SCROLLING), helpstring("Will be fired if the control is being scrolled. This event isn't raised if the 'MultiLine' property is set to 'False'. This event may be disabled.")]
			void Scrolling(ScrollAxisConstants axis);
			/// \brief <em>The text, that was entered into the control, got truncated</em>
			///
			/// Will be fired if the text, that was entered into the control, got truncated. This happens in the
			/// following situations:
			/// - The control's resulting text would have been longer than allowed by the \c MaxTextLength
			///   property.
			/// - The control would have to scroll horizontally to display the entered text, but the
			///   \c AutoScrolling property doesn't include \c asHorizontal.
			/// - The control would have to scroll vertically to display the entered text, but the
			///   \c AutoScrolling property doesn't include \c asVertical.
			///
			/// \sa ITextBox::Text, ITextBox::MaxTextLength, ITextBox::AutoScrolling
			[id(DISPID_TXTBOXE_TRUNCATEDTEXT), helpstring("Will be fired if the text, that was entered into the control, got truncated.")]
			void TruncatedText(void);
			/// \brief <em>The control's writing direction has been changed by the user</em>
			///
			/// Will be fired if the control's writing direction has been changed by the user.
			///
			/// \param[in] newWritingDirection The control's new writing direction. Any of the values defined by
			///            the \c WritingDirectionConstants enumeration is valid.
			///
			/// \remarks Due to limitations of Microsoft Windows, this event is not raised if the writing
			///          direction is changed using the control's default context menu.
			///
			/// \sa ITextBox::RightToLeft, WritingDirectionConstants
			[id(DISPID_TXTBOXE_WRITINGDIRECTIONCHANGED), helpstring("Will be fired if the control's writing direction has been changed by the user.")]
			void WritingDirectionChanged(WritingDirectionConstants newWritingDirection);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     ITextBox::DisabledEvents
			[id(DISPID_TXTBOXE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c TextBox class</em>
	///
	/// The control's main COM class. It implements the \c ITextBox and
	/// \c _ITextBoxEvents interfaces.
	///
	/// \sa ITextBox, _ITextBoxEvents
	[
		uuid(336D591B-C170-4e59-96C7-6E4848F3F8BC),
		version(1.10),
		helpstring("TextBox Control 1.10 (Unicode)")
	]
	coclass TextBox
	{
		[default] interface ITextBox;
		[default, source] dispinterface _ITextBoxEvents;
	};


	/// \interface IVirtualUpDownAccelerator
	/// \brief <em>Wraps a not existing up down accelerator</em>
	///
	/// This interface is a wrapper around an up down accelerator that does not yet exist within the up down
	/// control.
	///
	/// \sa _IVirtualUpDownAcceleratorEvents, IUpDownAccelerator, _IUpDownTextBoxEvents
	[
		object,
		uuid(6B4F4CA6-FB5C-4d05-BD65-A36BC8D23091),
		dual,
		nonextensible,
		helpstring("IVirtualUpDownAccelerator interface"),
		pointer_default(unique)
	]
	interface IVirtualUpDownAccelerator : IDispatch
	{
		/// \brief <em>Retrieves the number of seconds that must elapse, before this accelerator is used</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa StepSize, Index
		[propget, id(DISPID_VUDA_ACTIVATIONTIME), helpstring("Retrieves the number of seconds that must elapse, before this accelerator is used.")]
		HRESULT ActivationTime([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the accelerator's index</em>
		///
		/// Retrieves a zero-based index identifying this accelerator.
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_VUDA_INDEX), helpstring("Retrieves the accelerator's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the increment by which this accelerator changes the up down control's value</em>
		///
		/// \remarks This is the default property of the \c IUpDownAccelerator interface.\n
		///          This property is read-only.
		///
		/// \sa ActivationTime, IUpDownTextBox::CurrentValue, Index
		[propget, id(DISPID_VUDA_STEPSIZE), helpstring("Retrieves the increment by which this accelerator changes the up down control's value.")]
		HRESULT StepSize([out, retval] LONG* pValue);
	}


	/// \interface _IVirtualUpDownAcceleratorEvents
	/// \brief <em>The \c VirtualUpDownAccelerator class' events interface</em>
	///
	/// This interface defines all events the \c VirtualUpDownAccelerator class may raise.
	///
	/// \sa IVirtualUpDownAccelerator
	[
		uuid(10EE0205-2895-4c1f-BA4C-519D356FAA91),
		helpstring("IVirtualUpDownAccelerator-event-interface")
	]
	dispinterface _IVirtualUpDownAcceleratorEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualUpDownAccelerator class</em>
	///
	/// This COM class implements the \c IVirtualUpDownAccelerator and \c _IVirtualUpDownAcceleratorEvents
	/// interfaces.
	///
	/// \sa IVirtualUpDownAccelerator, _IVirtualUpDownAcceleratorEvents, UpDownTextBox,
	///     VirtualUpDownAccelerators
	[
		uuid(0D35892D-6260-415c-8657-521CFF8C9FB9),
		version(1.10),
		noncreatable,
		helpstring("VirtualUpDownAccelerator Class 1.10 (Unicode)")
	]
	coclass VirtualUpDownAccelerator
	{
		[default] interface IVirtualUpDownAccelerator;
		[default, source] dispinterface _IVirtualUpDownAcceleratorEvents;
	};


	/// \interface IVirtualUpDownAccelerators
	/// \brief <em>Manages a collection of \c VirtualUpDownAccelerator objects</em>
	///
	/// This interface provides easy access to collections of \c VirtualUpDownAccelerator objects. A
	/// \c VirtualUpDownAccelerators object is used to group accelerators that do not yet exist within
	/// the up down control.
	///
	/// \sa _IVirtualUpDownAcceleratorsEvents, IVirtualUpDownAccelerator, IUpDownTextBox
	[
		object,
		uuid(0012CB35-C78E-4f09-A30B-F863A18D6159),
		dual,
		nonextensible,
		helpstring("IVirtualUpDownAccelerators interface"),
		pointer_default(unique)
	]
	interface IVirtualUpDownAccelerators : IDispatch
	{
		/// \brief <em>Retrieves a \c VirtualUpDownAccelerator object from the collection</em>
		///
		/// Retrieves a \c VirtualUpDownAccelerator object from the collection that wraps the accelerator
		/// identified by \c acceleratorIndex.
		///
		/// \param[in] acceleratorIndex A value that identifies the up down accelerator to be retrieved.
		///
		/// \remarks This is the default property of the \c IVirtualUpDownAccelerators interface.\n
		///          This property is read-only.
		///
		/// \sa IVirtualUpDownAccelerator
		[propget, id(DISPID_VUDAS_ITEM), helpstring("Retrieves a 'VirtualUpDownAccelerator' object from the collection that wraps the accelerator identified by 'acceleratorIndex'."), nonbrowsable]
		HRESULT Item([in] LONG acceleratorIndex, [out, retval] IVirtualUpDownAccelerator** ppAccelerator);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c VirtualUpDownAccelerator
		///   objects managed by this collection object. This iterator is used by Visual Basic's
		///   \c For...Each construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_VUDAS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Counts the working areas in the collection</em>
		///
		/// Retrieves the number of \c VirtualUpDownAccelerator objects in the collection.
		///
		/// \return The number of elements in the collection.
		[id(DISPID_VUDAS_COUNT), helpstring("Retrieves the number of 'VirtualUpDownAccelerator' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
	}


	/// \interface _IVirtualUpDownAcceleratorsEvents
	/// \brief <em>The \c VirtualUpDownAccelerators class' events interface</em>
	///
	/// This interface defines all events the \c VirtualUpDownAccelerators class may raise.
	///
	/// \sa IVirtualUpDownAccelerators
	[
		uuid(17F174D8-8077-4bc4-A420-BF9B68DD2CAB),
		helpstring("IVirtualUpDownAccelerators-event-interface")
	]
	dispinterface _IVirtualUpDownAcceleratorsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualUpDownAccelerators class</em>
	///
	/// This COM class implements the \c IVirtualUpDownAccelerators and \c _IVirtualUpDownAcceleratorsEvents
	/// interfaces.
	///
	/// \sa IVirtualUpDownAccelerators, _IVirtualUpDownAcceleratorsEvents, UpDownTextBox,
	///     VirtualUpDownAccelerator
	[
		uuid(159EA95A-8BE0-4ff1-BCA2-A69455121F5A),
		version(1.10),
		noncreatable,
		helpstring("VirtualUpDownAccelerators Class 1.10 (Unicode)")
	]
	coclass VirtualUpDownAccelerators
	{
		[default] interface IVirtualUpDownAccelerators;
		[default, source] dispinterface _IVirtualUpDownAcceleratorsEvents;
	};


	/// \interface IUpDownAccelerator
	/// \brief <em>Wraps an existing up down accelerator</em>
	///
	/// This interface is a wrapper around an up down accelerator that - unlike an accelerator wrapped by
	/// \c IVirtualUpDownAccelerator - really exists within the up down control.
	///
	/// \sa _IUpDownAcceleratorEvents, IVirtualUpDownAccelerator, IUpDownAccelerators, IUpDownTextBox,
	///     _IUpDownTextBoxEvents
	[
		object,
		uuid(BFA91CE7-7AE9-4f1e-8EB6-9CE86B063DDD),
		dual,
		nonextensible,
		helpstring("IUpDownAccelerator interface"),
		pointer_default(unique)
	]
	interface IUpDownAccelerator : IDispatch
	{
		/// \brief <em>Specifies the time after which the accelerator is used</em>
		///
		/// Retrieves or sets the number of seconds that must elapse, before this accelerator is used.
		///
		/// \remarks Changing this property may change the \c Index property, because the accelerators will be
		///          sorted again.
		///
		/// \sa StepSize, Index
		[propget, id(DISPID_UDA_ACTIVATIONTIME), helpstring("Retrieves or sets the number of seconds that must elapse, before this accelerator is used.")]
		HRESULT ActivationTime([out, retval] LONG* pValue);
		[propput, id(DISPID_UDA_ACTIVATIONTIME), helpstring("Retrieves or sets the number of seconds that must elapse, before this accelerator is used.")]
		HRESULT ActivationTime([in] LONG newValue);
		/// \brief <em>Retrieves the accelerator's index</em>
		///
		/// Retrieves a zero-based index identifying this accelerator.
		///
		/// \remarks The accelerators are sorted by activation time and step size. Therefore, adding or
		///          removing accelerators or changing an accelerator's properties may change other
		///          accelerators' indexes.\n
		///          This property is read-only.
		[propget, id(DISPID_UDA_INDEX), helpstring("Retrieves the accelerator's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Controls the consequences that the accelerator has on the control's value</em>
		///
		/// Retrieves or sets the increment by which this accelerator changes the up down control's value.
		///
		/// \remarks Changing this property may change the \c Index property, because the accelerators will be
		///          sorted again.\n
		///          This is the default property of the \c IUpDownAccelerator interface.
		///
		/// \sa ActivationTime, IUpDownTextBox::CurrentValue, Index
		[propget, id(DISPID_UDA_STEPSIZE), helpstring("Retrieves or sets the increment by which this accelerator changes the up down control's value.")]
		HRESULT StepSize([out, retval] LONG* pValue);
		[propput, id(DISPID_UDA_STEPSIZE), helpstring("Retrieves or sets the increment by which this accelerator changes the up down control's value.")]
		HRESULT StepSize([in] LONG newValue);
	}


	/// \interface _IUpDownAcceleratorEvents
	/// \brief <em>The \c UpDownAccelerator class' events interface</em>
	///
	/// This interface defines all events the \c UpDownAccelerator class may raise.
	///
	/// \sa IUpDownAccelerator
	[
		uuid(0E57E978-EE4D-4035-BE47-D7CB466E745D),
		helpstring("IUpDownAccelerator-event-interface")
	]
	dispinterface _IUpDownAcceleratorEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c UpDownAccelerator class</em>
	///
	/// This COM class implements the \c IUpDownAccelerator and \c _IUpDownAcceleratorEvents interfaces.
	///
	/// \sa IUpDownAccelerator, _IUpDownAcceleratorEvents, UpDownTextBox, UpDownAccelerators
	[
		uuid(8B190BC6-9009-4704-A46A-CB3ABC1B68FC),
		version(1.10),
		noncreatable,
		helpstring("UpDownAccelerator Class 1.10 (Unicode)")
	]
	coclass UpDownAccelerator
	{
		[default] interface IUpDownAccelerator;
		[default, source] dispinterface _IUpDownAcceleratorEvents;
	};


	/// \interface IUpDownAccelerators
	/// \brief <em>Manages a collection of \c UpDownAccelerator objects</em>
	///
	/// This interface provides easy access to collections of \c UpDownAccelerator objects. A
	/// \c UpDownAccelerators object is used to group the up down control's accelerators.
	///
	/// \sa _IUpDownAcceleratorsEvents, IUpDownAccelerator, IUpDownTextBox
	[
		object,
		uuid(79842EE6-8A1A-4b49-B21D-145548430A75),
		dual,
		nonextensible,
		helpstring("IUpDownAccelerators interface"),
		pointer_default(unique)
	]
	interface IUpDownAccelerators : IDispatch
	{
		/// \brief <em>Retrieves a \c UpDownAccelerator object from the collection</em>
		///
		/// Retrieves a \c UpDownAccelerator object from the collection that wraps the accelerator identified
		/// by \c acceleratorIndex.
		///
		/// \param[in] acceleratorIndex A value that identifies the up down accelerator to be retrieved.
		///
		/// \remarks This is the default property of the \c IUpDownAccelerators interface.\n
		///          This property is read-only.
		///
		/// \sa IUpDownAccelerator, Add, Remove
		[propget, id(DISPID_UDAS_ITEM), helpstring("Retrieves a 'UpDownAccelerator' object from the collection that wraps the accelerator identified by 'acceleratorIndex'."), nonbrowsable]
		HRESULT Item([in] LONG acceleratorIndex, [out, retval] IUpDownAccelerator** ppAccelerator);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c UpDownAccelerator objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_UDAS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds an accelerator to the up down control</em>
		///
		/// Adds an accelerator with the specified properties to the control and returns an
		/// \c UpDownAccelerator object wrapping the inserted accelerator.
		///
		/// \param[in] activationTime The number of seconds that must elapse, before the new accelerator is
		///            used.
		/// \param[in] stepSize The increment by which the new accelerator changes the up down control's value.
		///
		/// \return The inserted accelerator.
		///
		/// \remarks The accelerators will be sorted by ascending activation time and ascending step size.
		///
		/// \sa Count, Remove, RemoveAll, IUpDownAccelerator::ActivationTime, IUpDownAccelerator::StepSize,
		///     IUpDownTextBox::CurrentValue
		[id(DISPID_UDAS_ADD), helpstring("Adds a new accelerator with the specified properties. The accelerators will be sorted by ascending activation time and ascending step size.")]
		HRESULT Add([in] LONG ActivationTime, [in] LONG StepSize, [out, retval] IUpDownAccelerator** ppAddedAccelerator);
		/// \brief <em>Counts the accelerators in the collection</em>
		///
		/// Retrieves the number of \c UpDownAccelerator objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_UDAS_COUNT), helpstring("Retrieves the number of 'UpDownAccelerator' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified accelerator in the collection from the up down control</em>
		///
		/// \param[in] acceleratorIndex A value that identifies the up down accelerator to be removed.
		///
		/// \remarks An up down control must have at least one accelerator. If calling this method would make
		///          this condition fail, a new accelerator with \c ActivationTime and \c StepSize both set to
		///          0 is inserted.
		///
		/// \sa Add, Count, RemoveAll, IUpDownAccelerator::ActivationTime, IUpDownAccelerator::StepSize
		[id(DISPID_UDAS_REMOVE), helpstring("Removes the specified accelerator in the collection from the control.")]
		HRESULT Remove([in] LONG acceleratorIndex);
		/// \brief <em>Removes all accelerators in the collection from the up down control</em>
		///
		/// \remarks An up down control must have at least one accelerator. If calling this method would make
		///          this condition fail, a new accelerator with \c ActivationTime and \c StepSize both set to
		///          0 is inserted.
		///
		/// \sa Add, Count, Remove, IUpDownAccelerator::ActivationTime, IUpDownAccelerator::StepSize
		[id(DISPID_UDAS_REMOVEALL), helpstring("Removes all accelerators in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IUpDownAcceleratorsEvents
	/// \brief <em>The \c UpDownAccelerators class' events interface</em>
	///
	/// This interface defines all events the \c UpDownAccelerators class may raise.
	///
	/// \sa IUpDownAccelerators
	[
		uuid(093294D7-D647-456e-8007-7D358E2C5F43),
		helpstring("IUpDownAccelerators-event-interface")
	]
	dispinterface _IUpDownAcceleratorsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c UpDownAccelerators class</em>
	///
	/// This COM class implements the \c IUpDownAccelerators and \c _IUpDownAcceleratorsEvents interfaces.
	///
	/// \sa IUpDownAccelerators, _IUpDownAcceleratorsEvents, UpDownTextBox, UpDownAccelerator
	[
		uuid(4F3D09B9-1A9F-4408-88DD-4CAE6FB15F4D),
		version(1.10),
		noncreatable,
		helpstring("UpDownAccelerators Class 1.10 (Unicode)")
	]
	coclass UpDownAccelerators
	{
		[default] interface IUpDownAccelerators;
		[default, source] dispinterface _IUpDownAcceleratorsEvents;
	};


	/// \interface IUpDownTextBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the up down text box control's main interface. It wraps the control window.
	///
	/// \sa _IUpDownTextBoxEvents
	[
		object,
		uuid(1B5B9DE5-5F1F-493c-BD48-0CB0836763FB),
		dual,
		nonextensible,
		helpstring("IUpDownTextBox interface"),
		pointer_default(unique)
	]
	interface IUpDownTextBox : IDispatch
	{
		/// \brief <em>Retrieves a collection of the control's accelerators</em>
		///
		/// Retrieves a collection object wrapping the control's accelerators.\n
		/// The accelerators are used if the user changes the control's current value using the up down arrows.
		/// Each accelerator defines a number of seconds, that the user must change the value continuously,
		/// before the accelerator is used, and an increment by which the control's current value is changed on
		/// each step.\n
		/// The accelerators are sorted by ascending activation time and ascending step size.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IUpDownAccelerators, CurrentValue
		[propget, id(DISPID_UPDWNTXTBOX_ACCELERATORS), helpstring("Retrieves a collection object wrapping the control's accelerators."), nonbrowsable]
		HRESULT Accelerators([out, retval] IUpDownAccelerators** ppAccelerators);
		/// \brief <em>Specifies whether the control accepts numbers only</em>
		///
		/// Retrieves or sets whether the contained edit control accepts all kind of text or only numbers. If
		/// set to \c True, only numbers, otherwise all text is accepted.
		///
		/// \sa Text, CurrentValue
		[propget, id(DISPID_UPDWNTXTBOX_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how selected text is displayed</em>
		///
		/// Retrieves or sets whether the selected text will be highlighted even if the contained edit control
		/// doesn't have the focus. If set to \c True, selected text is drawn as selected if the contained edit
		/// control does not have the focus; otherwise it's drawn as normal text.
		///
		/// \attention Changing this property destroys and recreates the contained edit window.
		///
		/// \sa Text
		[propget, id(DISPID_UPDWNTXTBOX_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the contained edit control doesn't have the focus. Changing this property destroys and recreates the contained edit window.")]
		HRESULT AlwaysShowSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the contained edit control doesn't have the focus. Changing this property destroys and recreates the contained edit window.")]
		HRESULT AlwaysShowSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration except \c aDefault is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_UPDWNTXTBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the control automatically replaces invalid values</em>
		///
		/// Retrieves or sets whether the control ensures, that the value displayed by the contained edit
		/// control always is a valid value. In detail, the edit control's content is validated if the
		/// \c Minimum or \c Maximum property is changed and if the control loses the focus.\n
		/// If set to \c True, the displayed text is validated automatically and changed if necessary;
		/// otherwise not.
		///
		/// \sa Text, Minimum, Maximum, CurrentValue
		[propget, id(DISPID_UPDWNTXTBOX_AUTOMATICALLYCORRECTVALUE), helpstring("Retrieves or sets whether the control ensures, that the value displayed by the contained edit control always is a valid value.")]
		HRESULT AutomaticallyCorrectValue([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_AUTOMATICALLYCORRECTVALUE), helpstring("Retrieves or sets whether the control ensures, that the value displayed by the contained edit control always is a valid value.")]
		HRESULT AutomaticallyCorrectValue([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how the contained edit control is used to display the control's value</em>
		///
		/// Retrieves or sets whether the contained edit control's text automatically is set to the contained
		/// up down control's current value, if this value changes. If set to \c True, the text is changed
		/// automatically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa Text, CurrentValue, GroupDigits
		[propget, id(DISPID_UPDWNTXTBOX_AUTOMATICALLYSETTEXT), helpstring("Retrieves or sets whether the contained edit control's text automatically is set to the contained up down control's current value, if this value changes. Changing this property destroys and recreates the contained up down window.")]
		HRESULT AutomaticallySetText([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_AUTOMATICALLYSETTEXT), helpstring("Retrieves or sets whether the contained edit control's text automatically is set to the contained up down control's current value, if this value changes. Changing this property destroys and recreates the contained up down window.")]
		HRESULT AutomaticallySetText([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's automatic scrolling features</em>
		///
		/// Retrieves or sets the directions into which the contained edit control scrolls automatically, if
		/// the caret reaches the borders of the contained edit control's client area. Some combinations of the
		/// values defined by the \c AutoScrollingConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the contained edit window.
		///
		/// \sa AutoScrollingConstants
		[propget, id(DISPID_UPDWNTXTBOX_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the contained edit control scrolls automatically, if the caret reaches the borders of the contained edit control's client area. Changing this property destroys and recreates the contained edit window.")]
		HRESULT AutoScrolling([out, retval] AutoScrollingConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the contained edit control scrolls automatically, if the caret reaches the borders of the contained edit control's client area. Changing this property destroys and recreates the contained edit window.")]
		HRESULT AutoScrolling([in] AutoScrollingConstants newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa ForeColor, DisabledBackColor
		[propget, id(DISPID_UPDWNTXTBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the format of the control's value</em>
		///
		/// Retrieves or sets the format in which the current value is displayed in the contained edit control.
		/// Any of the values defined by the \c BaseConstants enumeration is valid.
		///
		/// \sa CurrentValue, AutomaticallySetText, BaseConstants
		[propget, id(DISPID_UPDWNTXTBOX_BASE), helpstring("Retrieves or sets the format in which the current value is displayed in the contained edit control.")]
		HRESULT Base([out, retval] BaseConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_BASE), helpstring("Retrieves or sets the format in which the current value is displayed in the contained edit control.")]
		HRESULT Base([in] BaseConstants newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_UPDWNTXTBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether the contained edit control cancels the IME composition string when it
		/// receives the focus. If set to \c True, the composition string is canceled; otherwise not.
		///
		/// \sa IMEMode, CompleteIMECompositionOnKillFocus
		[propget, id(DISPID_UPDWNTXTBOX_CANCELIMECOMPOSITIONONSETFOCUS), helpstring("Retrieves or sets whether the contained edit control cancels the IME composition string when it receives the focus.")]
		HRESULT CancelIMECompositionOnSetFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_CANCELIMECOMPOSITIONONSETFOCUS), helpstring("Retrieves or sets whether the contained edit control cancels the IME composition string when it receives the focus.")]
		HRESULT CancelIMECompositionOnSetFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's automatic character conversion features</em>
		///
		/// Retrieves or sets the kind of conversion that is applied to characters that are typed into the
		/// contained edit control. Any of the values defined by the \c CharacterConversionConstants
		/// enumeration is valid.
		///
		/// \sa DoOEMConversion, Text, CharacterConversionConstants
		[propget, id(DISPID_UPDWNTXTBOX_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the contained edit control.")]
		HRESULT CharacterConversion([out, retval] CharacterConversionConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the contained edit control.")]
		HRESULT CharacterConversion([in] CharacterConversionConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether the contained edit control completes the IME composition string when it
		/// loses the focus. If set to \c True, the composition string is completed; otherwise not.
		///
		/// \sa IMEMode, CancelIMECompositionOnSetFocus
		[propget, id(DISPID_UPDWNTXTBOX_COMPLETEIMECOMPOSITIONONKILLFOCUS), helpstring("Retrieves or sets whether the contained edit control completes the IME composition string when it loses the focus.")]
		HRESULT CompleteIMECompositionOnKillFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_COMPLETEIMECOMPOSITIONONKILLFOCUS), helpstring("Retrieves or sets whether the contained edit control completes the IME composition string when it loses the focus.")]
		HRESULT CompleteIMECompositionOnKillFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's textual cue</em>
		///
		/// Retrieves or sets the contained edit control's textual cue.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text, DisplayCueBannerOnFocus
		[propget, id(DISPID_UPDWNTXTBOX_CUEBANNER), helpstring("Retrieves or sets the contained edit control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([out, retval] BSTR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_CUEBANNER), helpstring("Retrieves or sets the contained edit control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([in] BSTR newValue);
		/// \brief <em>Specifies the control's current value</em>
		///
		/// Retrieves or sets the control's current value.
		///
		/// \param[out] invalidValue If \c True, the value currently displayed by the contained edit control
		///             is invalid; otherwise not. This parameter is ignored when setting the value.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa Text, AutomaticallySetText, AcceptNumbersOnly, _IUpDownTextBoxEvents::ValueChanging,
		///     _IUpDownTextBoxEvents::ValueChanged
		[propget, id(DISPID_UPDWNTXTBOX_CURRENTVALUE), helpstring("Retrieves or sets the control's current value."), bindable, immediatebind, displaybind, requestedit, defaultbind]
		HRESULT CurrentValue([in, out, defaultvalue(0)] VARIANT_BOOL* invalidValue, [out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_CURRENTVALUE), helpstring("Retrieves or sets the control's current value."), bindable, immediatebind, displaybind, requestedit, defaultbind]
		HRESULT CurrentValue([in, out, defaultvalue(0)] VARIANT_BOOL* invalidValue, [in] LONG newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the color used as the control's background color, if the control is read-only or
		/// disabled. If set to -1, the system's default color is used.
		///
		/// \sa Enabled, ReadOnlyTextBox, DisabledForeColor, BackColor
		[propget, id(DISPID_UPDWNTXTBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is read-only or disabled.")]
		HRESULT DisabledBackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DISABLEDBACKCOLOR), helpstring("Retrieves or sets the color used as the control's background color, if the control is read-only or disabled.")]
		HRESULT DisabledBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_UPDWNTXTBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the color used as the control's text color, if the control is read-only. If set
		/// to -1, the system's default color is used.
		///
		/// \remarks On current versions of Windows this property has no effect if the control is disabled.
		///
		/// \sa Enabled, ReadOnlyTextBox, DisabledBackColor, ForeColor
		[propget, id(DISPID_UPDWNTXTBOX_DISABLEDFORECOLOR), helpstring("Retrieves or sets the color used as the control's text color, if the control is read-only. On current versions of Windows this property has no effect if the control is disabled.")]
		HRESULT DisabledForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DISABLEDFORECOLOR), helpstring("Retrieves or sets the color used as the control's text color, if the control is read-only. On current versions of Windows this property has no effect if the control is disabled.")]
		HRESULT DisabledForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls when the control's textual cue is displayed</em>
		///
		/// Retrieves or sets whether the contained edit control's textual cue is displayed if the control has
		/// the keyboard focus. If set to \c True, the textual cue is displayed if the control has the keyboard
		/// focus; otherwise not.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa CueBanner
		[propget, id(DISPID_UPDWNTXTBOX_DISPLAYCUEBANNERONFOCUS), helpstring("Retrieves or sets whether the contained edit control's textual cue is displayed if the control has the keyboard focus. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT DisplayCueBannerOnFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DISPLAYCUEBANNERONFOCUS), helpstring("Retrieves or sets whether the contained edit control's textual cue is displayed if the control has the keyboard focus. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT DisplayCueBannerOnFocus([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_UPDWNTXTBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control tries to work-around character set problems related to filenames</em>
		///
		/// Retrieves or sets whether the contained edit control's text is converted from the Windows character
		/// set to the OEM character set and then back to the Windows character set. Such a conversion ensures
		/// proper character conversion when the application calls the \c CharToOem function to convert a
		/// Windows string in the contained edit control to OEM characters. This property is most useful if the
		/// contained edit control contains file names that will be used on file systems that do not support
		/// Unicode.\n
		/// If set to \c True, the conversion is performed; otherwise not.
		///
		/// \sa CharacterConversion, Text,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647473.aspx">CharToOem</a>
		[propget, id(DISPID_UPDWNTXTBOX_DOOEMCONVERSION), helpstring("Retrieves or sets whether the contained edit control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set.")]
		HRESULT DoOEMConversion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DOOEMCONVERSION), helpstring("Retrieves or sets whether the contained edit control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set.")]
		HRESULT DoOEMConversion([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		///
		/// \sa ReadOnlyTextBox
		[propget, id(DISPID_UPDWNTXTBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's first visible character</em>
		///
		/// Retrieves the zero-based index of the first visible character in the contained edit control.
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_UPDWNTXTBOX_FIRSTVISIBLECHAR), helpstring("Retrieves the zero-based index of the first visible character in the contained edit control. This property is read-only."), nonbrowsable]
		HRESULT FirstVisibleChar([out, retval] LONG* pValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, ForeColor, CurrentValue
		[propget, id(DISPID_UPDWNTXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_UPDWNTXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_UPDWNTXTBOX_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor, DisabledForeColor
		[propget, id(DISPID_UPDWNTXTBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Retrieves the height of the contained edit control's formatting rectangle</em>
		///
		/// Retrieves the height (in pixels) of the contained edit control's formatting rectangle.\n
		/// The visibility of the contained edit control's text is governed by the dimensions of its window
		/// rectangle and its formatting rectangle. The formatting rectangle is a construct maintained by the
		/// system for formatting the text displayed in the window rectangle. When the contained edit control
		/// is first displayed, the two rectangles are identical on the screen. An application can make the
		/// formatting rectangle larger than the window rectangle (thereby limiting the visibility of the
		/// contained edit control's text) or smaller than the window rectangle (thereby creating extra white
		/// space around the text).
		///
		/// \remarks This property is read-only.
		///
		/// \sa FormattingRectangleLeft, FormattingRectangleTop, FormattingRectangleWidth
		[propget, id(DISPID_UPDWNTXTBOX_FORMATTINGRECTANGLEHEIGHT), helpstring("Retrieves the height (in pixels) of the contained edit control's formatting rectangle. This property is read-only."), nonbrowsable]
		HRESULT FormattingRectangleHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the x-coordinate of the contained edit control's formatting rectangle</em>
		///
		/// Retrieves the distance (in pixels) between the left borders of the control's formatting rectangle
		/// and its client area.\n
		/// The visibility of the contained edit control's text is governed by the dimensions of its window
		/// rectangle and its formatting rectangle. The formatting rectangle is a construct maintained by the
		/// system for formatting the text displayed in the window rectangle. When the contained edit control
		/// is first displayed, the two rectangles are identical on the screen. An application can make the
		/// formatting rectangle larger than the window rectangle (thereby limiting the visibility of the
		/// contained edit control's text) or smaller than the window rectangle (thereby creating extra white
		/// space around the text).
		///
		/// \remarks This property is read-only.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleTop, FormattingRectangleWidth
		[propget, id(DISPID_UPDWNTXTBOX_FORMATTINGRECTANGLELEFT), helpstring("Retrieves the distance (in pixels) between the left borders of the contained edit control's formatting rectangle and its client area. This property is read-only."), nonbrowsable]
		HRESULT FormattingRectangleLeft([out, retval] OLE_XPOS_PIXELS* pValue);
		/// \brief <em>Retrieves the y-coordinate of the contained edit control's formatting rectangle</em>
		///
		/// Retrieves the distance (in pixels) between the upper borders of the control's formatting rectangle
		/// and its client area.\n
		/// The visibility of the contained edit control's text is governed by the dimensions of its window
		/// rectangle and its formatting rectangle. The formatting rectangle is a construct maintained by the
		/// system for formatting the text displayed in the window rectangle. When the contained edit control
		/// is first displayed, the two rectangles are identical on the screen. An application can make the
		/// formatting rectangle larger than the window rectangle (thereby limiting the visibility of the
		/// contained edit control's text) or smaller than the window rectangle (thereby creating extra white
		/// space around the text).
		///
		/// \remarks This property is read-only.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleWidth
		[propget, id(DISPID_UPDWNTXTBOX_FORMATTINGRECTANGLETOP), helpstring("Retrieves the distance (in pixels) between the upper borders of the contained edit control's formatting rectangle and its client area. This property is read-only."), nonbrowsable]
		HRESULT FormattingRectangleTop([out, retval] OLE_YPOS_PIXELS* pValue);
		/// \brief <em>Retrieves the width of the contained edit control's formatting rectangle</em>
		///
		/// Retrieves the width (in pixels) of the control's formatting rectangle.\n
		/// The visibility of the contained edit control's text is governed by the dimensions of its window
		/// rectangle and its formatting rectangle. The formatting rectangle is a construct maintained by the
		/// system for formatting the text displayed in the window rectangle. When the contained edit control
		/// is first displayed, the two rectangles are identical on the screen. An application can make the
		/// formatting rectangle larger than the window rectangle (thereby limiting the visibility of the
		/// contained edit control's text) or smaller than the window rectangle (thereby creating extra white
		/// space around the text).
		///
		/// \remarks This property is read-only.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleTop
		[propget, id(DISPID_UPDWNTXTBOX_FORMATTINGRECTANGLEWIDTH), helpstring("Retrieves the width (in pixels) of the contained edit control's formatting rectangle. This property is read-only."), nonbrowsable]
		HRESULT FormattingRectangleWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Controls how large numbers are displayed</em>
		///
		/// Retrieves or sets whether digits are grouped according to the locale settings when displaying the
		/// current value in the contained edit control. If set to \c True, digits are grouped; otherwise not.
		///
		/// \remarks This property has no effect if the \c AutomaticallySetText property is set to \c False.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa CurrentValue, AutomaticallySetText
		[propget, id(DISPID_UPDWNTXTBOX_GROUPDIGITS), helpstring("Retrieves or sets whether digits are grouped according to the locale settings when displaying the current value in the contained edit control. Changing this property destroys and recreates the contained up down window.")]
		HRESULT GroupDigits([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_GROUPDIGITS), helpstring("Retrieves or sets whether digits are grouped according to the locale settings when displaying the current value in the contained edit control. Changing this property destroys and recreates the contained up down window.")]
		HRESULT GroupDigits([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the horizontal alignment of the control's content</em>
		///
		/// Retrieves or sets the horizontal alignment of the control's content. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid.
		///
		/// \attention On Windows XP, changing this property destroys and recreates the edit control window.
		///
		/// \sa UpDownPosition, Text, HAlignmentConstants
		[propget, id(DISPID_UPDWNTXTBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Controls the control's mouse-hover effects</em>
		///
		/// Retrieves or sets whether the arrows get highlighted if the mouse cursor is moved over them. If set
		/// to \c True, the arrows get highlighted; otherwise not.
		///
		/// \remarks This property is ignored for themed up down controls.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		[propget, id(DISPID_UPDWNTXTBOX_HOTTRACKING), helpstring("Retrieves or sets whether the arrows get highlighted if the mouse cursor is moved over them. This property is ignored for themed up down controls. Changing this property destroys and recreates the contained up down window.")]
		HRESULT HotTracking([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_HOTTRACKING), helpstring("Retrieves or sets whether the arrows get highlighted if the mouse cursor is moved over them. This property is ignored for themed up down controls. Changing this property destroys and recreates the contained up down window.")]
		HRESULT HotTracking([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IUpDownTextBoxEvents::MouseHover
		[propget, id(DISPID_UPDWNTXTBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndEdit, hWndUpDown, _IUpDownTextBoxEvents::RecreatedControlWindow,
		///     _IUpDownTextBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_UPDWNTXTBOX_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained edit control's window handle</em>
		///
		/// Retrieves the window handle of the control's contained edit window.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndUpDown, _IUpDownTextBoxEvents::RecreatedControlWindow,
		///     _IUpDownTextBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_UPDWNTXTBOX_HWNDEDIT), helpstring("Retrieves the window handle of the control's contained edit window."), nonbrowsable]
		HRESULT hWndEdit([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained up down control's window handle</em>
		///
		/// Retrieves the window handle of the control's contained up down window.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndEdit, _IUpDownTextBoxEvents::RecreatedControlWindow,
		///     _IUpDownTextBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_UPDWNTXTBOX_HWNDUPDOWN), helpstring("Retrieves the window handle of the control's contained up down window."), nonbrowsable]
		HRESULT hWndUpDown([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_UPDWNTXTBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the width of the whitespace to the left of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the contained edit control's left margin. If set to -1,
		/// a value, that depends on the contained edit control's font, is used.
		///
		/// \sa RightMargin, Font
		[propget, id(DISPID_UPDWNTXTBOX_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the contained edit control's left margin.")]
		HRESULT LeftMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the contained edit control's left margin.")]
		HRESULT LeftMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the maximum value</em>
		///
		/// Retrieves or sets the maximum value that the user can select.
		///
		/// \sa Minimum, CurrentValue, WrapAtBoundaries
		[propget, id(DISPID_UPDWNTXTBOX_MAXIMUM), helpstring("Retrieves or sets the maximum value that the user can select.")]
		HRESULT Maximum([out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_MAXIMUM), helpstring("Retrieves or sets the maximum value that the user can select.")]
		HRESULT Maximum([in] LONG newValue);
		/// \brief <em>Specifies the maximum length of the input</em>
		///
		/// Retrieves or sets the maximum number of characters, that the user can type into the contained edit
		/// control. If set to -1, the system's default setting is used.
		///
		/// \remarks Text, that is set through the \c CurrentValue property may exceed this limit.
		///
		/// \sa Text, CurrentValue, _IUpDownTextBoxEvents::TruncatedText
		[propget, id(DISPID_UPDWNTXTBOX_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the contained edit control.")]
		HRESULT MaxTextLength([out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the contained edit control.")]
		HRESULT MaxTextLength([in] LONG newValue);
		/// \brief <em>Specifies the minimum value</em>
		///
		/// Retrieves or sets the minimum value that the user can select.
		///
		/// \sa Maximum, CurrentValue, WrapAtBoundaries
		[propget, id(DISPID_UPDWNTXTBOX_MINIMUM), helpstring("Retrieves or sets the minimum value that the user can select.")]
		HRESULT Minimum([out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_MINIMUM), helpstring("Retrieves or sets the minimum value that the user can select.")]
		HRESULT Minimum([in] LONG newValue);
		/// \brief <em>Retrieves or sets a flag indicating whether the control's content has changed</em>
		///
		/// Retrieves or sets a flag indicating whether the contained edit control's content has changed. A
		/// value of \c True stands for changed content, a value of \c False for unchanged content.
		///
		/// \sa Text, _IUpDownTextBoxEvents::TextChanged
		[propget, id(DISPID_UPDWNTXTBOX_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the contained edit control's content has changed.")]
		HRESULT Modified([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the contained edit control's content has changed.")]
		HRESULT Modified([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_UPDWNTXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_UPDWNTXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_UPDWNTXTBOX_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_UPDWNTXTBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Controls the control's orientation</em>
		///
		/// Retrieves or sets the control's orientation. Any of the values defined by the
		/// \c OrientationConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa UpDownPosition, OrientationConstants
		[propget, id(DISPID_UPDWNTXTBOX_ORIENTATION), helpstring("Retrieves or sets the control's orientation. Changing this property destroys and recreates the contained up down window.")]
		HRESULT Orientation([out, retval] OrientationConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_ORIENTATION), helpstring("Retrieves or sets the control's orientation. Changing this property destroys and recreates the contained up down window.")]
		HRESULT Orientation([in] OrientationConstants newValue);
		/// \brief <em>Specifies whether the control's value can be changed using the arrow keys on the keyboard</em>
		///
		/// Retrieves or sets whether the current value is incremented or decremented if the user presses the
		/// [UP] or [DOWN] arrow key. If set to \c True, the current value is changed; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa CurrentValue, ProcessContextMenuKeys
		[propget, id(DISPID_UPDWNTXTBOX_PROCESSARROWKEYS), helpstring("Retrieves or sets whether the current value is incremented or decremented if the user presses the [UP] or [DOWN] arrow key. Changing this property destroys and recreates the contained up down window.")]
		HRESULT ProcessArrowKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_PROCESSARROWKEYS), helpstring("Retrieves or sets whether the current value is incremented or decremented if the user presses the [UP] or [DOWN] arrow key. Changing this property destroys and recreates the contained up down window.")]
		HRESULT ProcessArrowKeys([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa ProcessArrowKeys, _IUpDownTextBoxEvents::ContextMenu
		[propget, id(DISPID_UPDWNTXTBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the user can edit the displayed text</em>
		///
		/// Retrieves or sets whether the contained edit control accepts user input, that would change its
		/// content.
		/// If set to \c False, such user input is accepted; otherwise not.
		///
		/// \remarks If this property is set to \c True, the user is still able to change the content by
		///          clicking the up down control's buttons or using the arrow keys on the keyboard.
		///
		/// \sa Enabled, Text
		[propget, id(DISPID_UPDWNTXTBOX_READONLYTEXTBOX), helpstring("Retrieves or sets whether the contained edit control accepts user input, that would change its content.")]
		HRESULT ReadOnlyTextBox([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_READONLYTEXTBOX), helpstring("Retrieves or sets whether the contained edit control accepts user input, that would change its content.")]
		HRESULT ReadOnlyTextBox([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IUpDownTextBoxEvents::OLEDragEnter
		[propget, id(DISPID_UPDWNTXTBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the width of the whitespace to the right of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the contained edit control's right margin. If set to -1,
		/// a value, that depends on the contained edit control's font, is used.
		///
		/// \sa LeftMargin, Font
		[propget, id(DISPID_UPDWNTXTBOX_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the contained edit control's right margin.")]
		HRESULT RightMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the contained edit control's right margin.")]
		HRESULT RightMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa IMEMode, _IUpDownTextBoxEvents::WritingDirectionChanged, RightToLeftConstants
		[propget, id(DISPID_UPDWNTXTBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Retrieves the currently selected text</em>
		///
		/// Retrieves the currently selected text.
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetSelection, SetSelection, ReplaceSelectedText, Text
		[propget, id(DISPID_UPDWNTXTBOX_SELECTEDTEXT), helpstring("Retrieves or replaces the currently selected text. This property is read-only."), nonbrowsable]
		HRESULT SelectedText([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_UPDWNTXTBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_UPDWNTXTBOX_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the contained edit control's content</em>
		///
		/// Retrieves or sets the contained edit control's content.
		///
		/// \sa CurrentValue, AutomaticallySetText, DoOEMConversion, MaxTextLength, AcceptNumbersOnly,
		///     CueBanner, HAlignment, ForeColor, Font, _IUpDownTextBoxEvents::TextChanged
		[propget, id(DISPID_UPDWNTXTBOX_TEXT), helpstring("Retrieves or sets the contained edit control's content."), bindable, displaybind, requestedit]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_TEXT), helpstring("Retrieves or sets the contained edit control's content."), bindable, displaybind, requestedit]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies the position of the contained up down control relative to the contained edit control</em>
		///
		/// Retrieves or sets the location of the contained up down control relative to the contained edit
		/// control. Any of the values defined by the \c UpDownPositionConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa HAlignment, Orientation, UpDownPositionConstants
		[propget, id(DISPID_UPDWNTXTBOX_UPDOWNPOSITION), helpstring("Retrieves or sets the location of the contained up down control relative to the contained edit control. Changing this property destroys and recreates the contained up down window.")]
		HRESULT UpDownPosition([out, retval] UpDownPositionConstants* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_UPDOWNPOSITION), helpstring("Retrieves or sets the location of the contained up down control relative to the contained edit control. Changing this property destroys and recreates the contained up down window.")]
		HRESULT UpDownPosition([in] UpDownPositionConstants newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_UPDWNTXTBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_UPDWNTXTBOX_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Controls word processing</em>
		///
		/// Retrieves or sets the function that is responsible to tell the contained edit control where a word
		/// starts and where it ends. This property takes the address of a function having the following
		/// signature:\n
		/// \code
		///   FindWorkBreak(ByVal pText As Long, ByVal startPosition As Long, ByVal textLength As Long, ByVal flags As Long) As Long
		/// \endcode
		/// The \c pText argument is a pointer to the contained edit control's text. In ANSI builds of the
		/// control, this text is encoded in ANSI; otherwise it's encoded in Unicode.\n
		/// The \c startPosition argument specifies the (zero-based) position within the text, at which the
		/// function should begin checking for a word break.\n
		/// The \c textLength argument specifies the length of the text pointed to by \c pText in characters.\n
		/// The \c flags argument specifies the action to be taken by the function. This can be one of the
		/// following values:
		/// - \c WB_ISDELIMITER Check whether the character at the specified position is a delimiter.
		/// - \c WB_LEFT Find the beginning of a word to the left of the specified position.
		/// - \c WB_RIGHT Find the beginning of a word to the right of the specified position. This is useful
		///   in right-aligned edit controls.
		///
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is a delimiter, the function must return a non-zero value.\n
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is not a delimiter, the function must return zero.\n
		/// If the \c flags parameter specifies \c WB_LEFT or \c WB_RIGHT, the function must return the
		/// (zero-based) index to the beginning of a word in the specified text.\n\n
		/// If this property is set to 0, the system's internal function is used.
		///
		/// \sa Text, HAlignment,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms672125.aspx">EditWordBreakProc</a>
		[propget, id(DISPID_UPDWNTXTBOX_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the contained edit control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([out, retval] LONG* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the contained edit control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([in] LONG newValue);
		/// \brief <em>Controls the control's behavior if the minimum or maximum value is reached</em>
		///
		/// Retrieves or sets whether the current value "wraps" to the opposite end of the range if it is
		/// incremented or decremented beyond the ending or beginning of the range.
		/// If set to \c True, the value "wraps"; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the contained up down window.
		///
		/// \sa Maximum, Minimum, CurrentValue
		[propget, id(DISPID_UPDWNTXTBOX_WRAPATBOUNDARIES), helpstring("Retrieves or sets whether the current value 'wraps' to the opposite end of the range if it is incremented or decremented beyond the ending or beginning of the range. Changing this property destroys and recreates the contained up down window.")]
		HRESULT WrapAtBoundaries([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_WRAPATBOUNDARIES), helpstring("Retrieves or sets whether the current value 'wraps' to the opposite end of the range if it is incremented or decremented beyond the ending or beginning of the range. Changing this property destroys and recreates the contained up down window.")]
		HRESULT WrapAtBoundaries([in] VARIANT_BOOL newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_UPDWNTXTBOX_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Determines whether there are any actions in the contained edit control's undo queue</em>
		///
		/// \return \c True if there are actions in the undo queue; otherwise \c False.
		///
		/// \sa Undo, EmptyUndoBuffer
		[id(DISPID_UPDWNTXTBOX_CANUNDO), helpstring("Determines whether there are any actions in the contained edit control's undo queue.")]
		HRESULT CanUndo([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the specified character's position in client coordinates</em>
		///
		/// Retrieves the position (in pixels) of the specified character within the contained edit control's
		/// client area.
		///
		/// \param[in] characterIndex The zero-based index of the character within the control, for which to
		///            retrieve the position. If the specified index is greater than the index of the last
		///            character in the contained edit control, the function fails.
		/// \param[out] x The x-coordinate (in pixels) of the character relative to the contained edit
		///             control's upper-left corner.
		/// \param[out] y The y-coordinate (in pixels) of the character relative to the contained edit
		///             control's upper-left corner.
		///
		/// \sa PositionToCharIndex
		[id(DISPID_UPDWNTXTBOX_CHARINDEXTOPOSITION), helpstring("Retrieves the position (in pixels) of the specified character within the contained edit control's client area.")]
		HRESULT CharIndexToPosition([in] LONG characterIndex, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* x, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* y);
		/// \brief <em>Clears the contained edit control's undo queue</em>
		///
		/// \sa CanUndo, Undo
		[id(DISPID_UPDWNTXTBOX_EMPTYUNDOBUFFER), helpstring("Clears the contained edit control's undo queue.")]
		HRESULT EmptyUndoBuffer(void);
		/// \brief <em>Retrieves the current selection's start and end</em>
		///
		/// Retrieves the zero-based character indices of the current selection's start and end.
		///
		/// \param[out] selectionStart The zero-based index of the character at which the selection starts.
		/// \param[out] selectionEnd The zero-based index of the first unselected character after the end of
		///             the selection.
		///
		/// \sa SetSelection, ReplaceSelectedText, SelectedText
		[id(DISPID_UPDWNTXTBOX_GETSELECTION), helpstring("Retrieves the zero-based character indices of the current selection's start and end.")]
		HRESULT GetSelection([in, out, defaultvalue(0)] LONG* selectionStart, [in, out, defaultvalue(0)] LONG* selectionEnd);
		/// \brief <em>Hides any balloon tips associated with the contained edit control</em>
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa ShowBalloonTip
		[id(DISPID_UPDWNTXTBOX_HIDEBALLOONTIP), helpstring("Hides any balloon tips associated with the contained edit control. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT HideBalloonTip([out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		///
		/// \return A value specifying the exact part of the control the specified point lies in. Any of the
		///         values defined by the \c HitTestConstants enumeration is valid.
		///
		/// \sa HitTestConstants
		[id(DISPID_UPDWNTXTBOX_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [out, retval] HitTestConstants* pHitTestDetails);
		/// \brief <em>Determines whether the text displayed by the contained edit control is entirely visible or truncated</em>
		///
		/// \return \c True if not all of the text is visible; otherwise \c False.
		[id(DISPID_UPDWNTXTBOX_ISTEXTTRUNCATED), helpstring("Determines whether the text displayed by the contained edit control is entirely visible or truncated.")]
		HRESULT IsTextTruncated([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_UPDWNTXTBOX_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Retrieves the character closest to the specified position</em>
		///
		/// Retrieves the zero-based index of the character nearest the specified position.
		///
		/// \param[in] x The x-coordinate (in pixels) of the position to retrieve the nearest character for. It
		///            is relative to the contained edit control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the position to retrieve the nearest character for. It
		///            is relative to the contained edit control's upper-left corner.
		/// \param[out] characterIndex The zero-based index of the character within the contained edit control,
		///             that is nearest to the specified position. If the specified point is beyond the last
		///             character in the contained edit control, this value indicates the last character in the
		///             contained edit control.
		///
		/// \remarks If a point outside the bounds of the contained edit control is passed, the function fails.
		///
		/// \sa CharIndexToPosition
		[id(DISPID_UPDWNTXTBOX_POSITIONTOCHARINDEX), helpstring("Retrieves the zero-based index of the character nearest the specified position.")]
		HRESULT PositionToCharIndex([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out, defaultvalue(0)] LONG* characterIndex);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_UPDWNTXTBOX_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Replaces the currently selected text</em>
		///
		/// Replaces the contained edit control's currently selected text.
		///
		/// \param[in] replacementText The text that replaces the currently selected text.
		/// \param[in] undoable If \c True, this action is inserted into the contained edit control's undo
		///            queue; otherwise not.
		///
		/// \sa GetSelection, SetSelection, SelectedText
		[id(DISPID_UPDWNTXTBOX_REPLACESELECTEDTEXT), helpstring("Replaces the contained edit control's currently selected text.")]
		HRESULT ReplaceSelectedText([in] BSTR replacementText, [in, defaultvalue(0)] VARIANT_BOOL undoable);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_UPDWNTXTBOX_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Scrolls the contained edit control so that the caret is visible</em>
		///
		/// Ensures that the contained edit control's caret is visible by scrolling the contained edit control
		/// if necessary.
		///
		/// \sa AutoScrolling
		[id(DISPID_UPDWNTXTBOX_SCROLLCARETINTOVIEW), helpstring("Ensures that the contained edit control's caret is visible by scrolling the contained edit control if necessary.")]
		HRESULT ScrollCaretIntoView(void);
		/// \brief <em>Sets the selection's start and end</em>
		///
		/// Sets the zero-based character indices of the selection's start and end.
		///
		/// \param[in] selectionStart The zero-based index of the character at which the selection starts. If
		///            set to -1, the current selection is cleared.
		/// \param[in] selectionEnd The zero-based index of the first unselected character after the end of
		///            the selection.
		///
		/// \remarks To select all text in the contained edit control, set \c selectionStart to 0 and
		///          \c selectionEnd to -1.
		///
		/// \sa GetSelection, ReplaceSelectedText, SelectedText
		[id(DISPID_UPDWNTXTBOX_SETSELECTION), helpstring("Sets the zero-based character indices of the selection's start and end.")]
		HRESULT SetSelection([in] LONG selectionStart, [in] LONG selectionEnd);
		/// \brief <em>Displays a balloon tip associated with the contained edit control</em>
		///
		/// \param[in] title The title of the balloon tip to display.
		/// \param[in] text The balloon tip text to display.
		/// \param[in] icon The icon of the balloon tip to display. Any of the values defined by the
		///            \c BalloonTipIconConstants enumeration is valid.
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa HideBalloonTip, BalloonTipIconConstants
		[id(DISPID_UPDWNTXTBOX_SHOWBALLOONTIP), helpstring("Displays a balloon tip associated with the contained edit control. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT ShowBalloonTip([in] BSTR title, [in] BSTR text, [in, defaultvalue(btiNone)] BalloonTipIconConstants icon, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Undoes the last action in the contained edit control's undo queue</em>
		///
		/// \return \c True on success; otherwise \c False.
		///
		/// \sa CanUndo, EmptyUndoBuffer
		[id(DISPID_UPDWNTXTBOX_UNDO), helpstring("Undoes the last action in the contained edit control's undo queue.")]
		HRESULT Undo([out, retval] VARIANT_BOOL* pSucceeded);

		/// \brief <em>Specifies whether the control intercepts double clicks</em>
		///
		/// Enables or disables double clicks. If set to \c True, double clicks are accepted; otherwise all
		/// clicks are handled as single clicks.
		///
		/// \remarks This property affects the up-down window only.\n
		///          Enabling double-clicks may lead to accidental double-clicks.
		///
		/// \sa _IUpDownTextBoxEvents::DblClick, _IUpDownTextBoxEvents::MDblClick,
		///     _IUpDownTextBoxEvents::RDblClick, _IUpDownTextBoxEvents::XDblClick
		[propget, id(DISPID_UPDWNTXTBOX_DETECTDOUBLECLICKS), helpstring("Enables or disables double clicks. Enabling double-clicks may lead to accidental double-clicks.")]
		HRESULT DetectDoubleClicks([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_UPDWNTXTBOX_DETECTDOUBLECLICKS), helpstring("Enables or disables double clicks. Enabling double-clicks may lead to accidental double-clicks.")]
		HRESULT DetectDoubleClicks([in] VARIANT_BOOL newValue);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IUpDownTextBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_UPDWNTXTBOX_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IUpDownTextBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c UpDownTextBox class' events interface</em>
	///
	/// This interface defines all events the \c UpDownTextBox class may raise.
	///
	/// \sa IUpDownTextBox
	[
		uuid(56704B47-1252-4f32-89CB-AAF5977256DB),
		helpstring("IUpDownTextBox-event-interface")
	]
	dispinterface _IUpDownTextBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The control's current value was changed</em>
			///
			/// Will be fired after the control's value was changed.
			///
			/// \remarks This is the control's default event.\n
			///          This event may be disabled.
			///
			/// \sa ValueChanging, IUpDownTextBox::CurrentValue, TextChanged
			[id(DISPID_UPDWNTXTBOXE_VALUECHANGED), helpstring("Will be fired after the control's value was changed. This event may be disabled.")]
			void ValueChanged(void);
			/// \brief <em>The contained edit control's text is about to be drawn</em>
			///
			/// Will be fired before the contained edit control's content is drawn. This makes it possible to
			/// resize the control, if necessary.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IUpDownTextBox::Text
			[id(DISPID_UPDWNTXTBOXE_BEFOREDRAWTEXT), helpstring("Will be fired before the contained edit control's content is drawn. This event may be disabled.")]
			void BeforeDrawText(void);
			/// \brief <em>The up down accelerators were changed</em>
			///
			/// Will be fired after the control's accelerators were redefined.
			///
			/// \param[in] accelerators A collection of the new accelerators.
			///
			/// \sa ChangingAccelerators, IUpDownAccelerators, IUpDownTextBox::Accelerators
			[id(DISPID_UPDWNTXTBOXE_CHANGEDACCELERATORS), helpstring("Will be fired after the control's accelerators were redefined.")]
			void ChangedAccelerators(IUpDownAccelerators* Accelerators);
			/// \brief <em>The up down accelerators are about to are changed</em>
			///
			/// Will be fired before the control's accelerators are redefined.
			///
			/// \param[in] accelerators A collection of the new accelerators.
			/// \param[in,out] cancelChanges If set to \c True, redefining is aborted, i. e. the accelerators
			///                remain the same. If set to \c False, the accelerators are redefined.
			///
			/// \sa ChangedAccelerators, IVirtualUpDownAccelerators, IUpDownTextBox::Accelerators
			[id(DISPID_UPDWNTXTBOXE_CHANGINGACCELERATORS), helpstring("Will be fired before the control's accelerators are redefined.")]
			void ChangingAccelerators(IVirtualUpDownAccelerators* Accelerators, VARIANT_BOOL* cancelChanges);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Any of the values defined
			///            by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The part of the control that the menu's proposed position lies in.
			///            Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, IUpDownTextBox::DetectDoubleClicks,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IUpDownTextBox::hWnd
			[id(DISPID_UPDWNTXTBOXE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IUpDownTextBox::DisabledEvents
			[id(DISPID_UPDWNTXTBOXE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IUpDownTextBox::DisabledEvents
			[id(DISPID_UPDWNTXTBOXE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IUpDownTextBox::DisabledEvents
			[id(DISPID_UPDWNTXTBOXE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Any of the values defined
			///            by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, IUpDownTextBox::DetectDoubleClicks,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ITextBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IUpDownTextBox::HoverTime, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, ScrollAxisConstants, IUpDownTextBox::DisabledEvents,
			///     HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp,
			///     IUpDownTextBox::RegisterForOLEDragDrop, IUpDownTextBox::FinishOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter,
			///     IUpDownTextBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave,
			///     IUpDownTextBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IUpDownTextBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the contained edit control cannot allocate enough memory to meet a specific
			/// request.
			[id(DISPID_UPDWNTXTBOXE_OUTOFMEMORY), helpstring("Will be fired if the contained edit control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Any of the values defined
			///            by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, IUpDownTextBox::DisabledEvents,
			///     HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, IUpDownTextBox::DetectDoubleClicks,
			///     IUpDownTextBox::DisabledEvents, HitTestConstants
			[id(DISPID_UPDWNTXTBOXE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IUpDownTextBox::hWnd
			[id(DISPID_UPDWNTXTBOXE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_UPDWNTXTBOXE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The control's text was changed</em>
			///
			/// Will be fired after the contained edit control's content was changed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IUpDownTextBox::Text, ValueChanged
			[id(DISPID_UPDWNTXTBOXE_TEXTCHANGED), helpstring("Will be fired after the contained edit control's content was changed. This event may be disabled.")]
			void TextChanged(void);
			/// \brief <em>The text, that was entered into the control, got truncated</em>
			///
			/// Will be fired if the text, that was entered into the contained edit control, got truncated. This
			/// happens in the following situations:
			/// - The contained edit control's resulting text would have been longer than allowed by the
			///   \c MaxTextLength property.
			/// - The contained edit control would have to scroll horizontally to display the entered text, but
			///   the \c AutoScrolling property doesn't include \c asHorizontal.
			///
			/// \sa IUpDownTextBox::Text, IUpDownTextBox::MaxTextLength, IUpDownTextBox::AutoScrolling
			[id(DISPID_UPDWNTXTBOXE_TRUNCATEDTEXT), helpstring("Will be fired if the text, that was entered into the contained edit control, got truncated.")]
			void TruncatedText(void);
			/// \brief <em>The control's current value is about to change</em>
			///
			/// Will be fired before the control's value is changed.
			///
			/// \param[in] currentValue The control's current value.
			/// \param[in] delta The value by which the control's value is about to change.
			/// \param[in,out] cancelChange If set to \c True, the value change is aborted, i. e. the control's
			///                value remains the same. In this case the \c ValueChanged event isn't fired. If set
			///                to \c False, the value change is completed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ValueChanged, IUpDownTextBox::CurrentValue, TextChanged
			[id(DISPID_UPDWNTXTBOXE_VALUECHANGING), helpstring("Will be fired before the control's value is changed. This event may be disabled.")]
			void ValueChanging(LONG CurrentValue, LONG delta, VARIANT_BOOL* cancelChange);
			/// \brief <em>The control's writing direction has been changed by the user</em>
			///
			/// Will be fired if the contained edit control's writing direction has been changed by the user.
			///
			/// \param[in] newWritingDirection The contained edit control's new writing direction. Any of the
			///            values defined by the \c WritingDirectionConstants enumeration is valid.
			///
			/// \remarks Due to limitations of Microsoft Windows, this event is not raised if the writing
			///          direction is changed using the contained edit control's default context menu.
			///
			/// \sa IUpDownTextBox::RightToLeft, WritingDirectionConstants
			[id(DISPID_UPDWNTXTBOXE_WRITINGDIRECTIONCHANGED), helpstring("Will be fired if the contained edit control's writing direction has been changed by the user.")]
			void WritingDirectionChanged(WritingDirectionConstants newWritingDirection);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DisabledEvents
			[id(DISPID_UPDWNTXTBOXE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants,
			///     IUpDownTextBox::DetectDoubleClicks, IUpDownTextBox::DisabledEvents
			[id(DISPID_UPDWNTXTBOXE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c UpDownTextBox class</em>
	///
	/// The control's main COM class. It implements the \c IUpDownTextBox and
	/// \c _IUpDownTextBoxEvents interfaces.
	///
	/// \sa IUpDownTextBox, _IUpDownTextBoxEvents
	[
		uuid(D4D26612-2A29-480c-8DD2-DA0B3205E635),
		version(1.10),
		helpstring("UpDownTextBox Control 1.10 (Unicode)")
	]
	coclass UpDownTextBox
	{
		[default] interface IUpDownTextBox;
		[default, source] dispinterface _IUpDownTextBoxEvents;
	};


	[
		uuid(E35CA24E-D986-4570-89B4-5C03B2784B0C),
		version(1.10),
		noncreatable,
		helpstring("CommonProperties Class 1.10 (Unicode)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};


	[
		uuid(6D2E4D8F-1EC0-4fb4-8E38-D1E46C95B047),
		version(1.10),
		noncreatable,
		helpstring("StringProperties Class 1.10 (Unicode)"),
		hidden
	]
	coclass StringProperties
	{
		[default] interface IUnknown;
	};
};
